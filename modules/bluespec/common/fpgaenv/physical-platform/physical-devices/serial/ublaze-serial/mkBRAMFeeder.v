//
// Generated by Bluespec Compiler, version 2009.03.beta1 (build 16153, 2009-03-03)
//
// On Sun Jul 26 17:19:48 EDT 2009
//
// Method conflict info:
// Method: ppcMessageInput_put
// Conflict-free: ppcMessageOutput_get,
// 	       bramInitiatorWires_bramRST,
// 	       bramInitiatorWires_bramAddr,
// 	       bramInitiatorWires_bramDout,
// 	       bramInitiatorWires_bramDin,
// 	       bramInitiatorWires_bramWEN,
// 	       bramInitiatorWires_bramEN
// Conflicts: ppcMessageInput_put
//
// Method: ppcMessageOutput_get
// Conflict-free: ppcMessageInput_put,
// 	       bramInitiatorWires_bramRST,
// 	       bramInitiatorWires_bramAddr,
// 	       bramInitiatorWires_bramDout,
// 	       bramInitiatorWires_bramDin,
// 	       bramInitiatorWires_bramWEN,
// 	       bramInitiatorWires_bramEN
// Conflicts: ppcMessageOutput_get
//
// Method: bramInitiatorWires_bramRST
// Conflict-free: ppcMessageInput_put,
// 	       ppcMessageOutput_get,
// 	       bramInitiatorWires_bramRST,
// 	       bramInitiatorWires_bramAddr,
// 	       bramInitiatorWires_bramDout,
// 	       bramInitiatorWires_bramDin,
// 	       bramInitiatorWires_bramWEN,
// 	       bramInitiatorWires_bramEN
//
// Method: bramInitiatorWires_bramAddr
// Conflict-free: ppcMessageInput_put,
// 	       ppcMessageOutput_get,
// 	       bramInitiatorWires_bramRST,
// 	       bramInitiatorWires_bramAddr,
// 	       bramInitiatorWires_bramDout,
// 	       bramInitiatorWires_bramDin,
// 	       bramInitiatorWires_bramWEN,
// 	       bramInitiatorWires_bramEN
//
// Method: bramInitiatorWires_bramDout
// Conflict-free: ppcMessageInput_put,
// 	       ppcMessageOutput_get,
// 	       bramInitiatorWires_bramRST,
// 	       bramInitiatorWires_bramAddr,
// 	       bramInitiatorWires_bramDout,
// 	       bramInitiatorWires_bramDin,
// 	       bramInitiatorWires_bramWEN,
// 	       bramInitiatorWires_bramEN
//
// Method: bramInitiatorWires_bramDin
// Conflict-free: ppcMessageInput_put,
// 	       ppcMessageOutput_get,
// 	       bramInitiatorWires_bramRST,
// 	       bramInitiatorWires_bramAddr,
// 	       bramInitiatorWires_bramDout,
// 	       bramInitiatorWires_bramWEN,
// 	       bramInitiatorWires_bramEN
// Conflicts: bramInitiatorWires_bramDin
//
// Method: bramInitiatorWires_bramWEN
// Conflict-free: ppcMessageInput_put,
// 	       ppcMessageOutput_get,
// 	       bramInitiatorWires_bramRST,
// 	       bramInitiatorWires_bramAddr,
// 	       bramInitiatorWires_bramDout,
// 	       bramInitiatorWires_bramDin,
// 	       bramInitiatorWires_bramWEN,
// 	       bramInitiatorWires_bramEN
//
// Method: bramInitiatorWires_bramEN
// Conflict-free: ppcMessageInput_put,
// 	       ppcMessageOutput_get,
// 	       bramInitiatorWires_bramRST,
// 	       bramInitiatorWires_bramAddr,
// 	       bramInitiatorWires_bramDout,
// 	       bramInitiatorWires_bramDin,
// 	       bramInitiatorWires_bramWEN,
// 	       bramInitiatorWires_bramEN
//
//
// Ports:
// Name                         I/O  size props
// RDY_ppcMessageInput_put        O     1
// ppcMessageOutput_get           O    32 reg
// RDY_ppcMessageOutput_get       O     1 reg
// bramInitiatorWires_bramRST     O     1 const
// bramInitiatorWires_bramAddr    O    14 reg
// bramInitiatorWires_bramDout    O    32 reg
// bramInitiatorWires_bramWEN     O     4
// bramInitiatorWires_bramEN      O     1
// CLK_bramInitiatorWires_bramCLK  O     1
// CLK_GATE_bramInitiatorWires_bramCLK  O     1 const
// CLK                            I     1
// RST_N                          I     1 reset
// ppcMessageInput_put            I    32 reg
// bramInitiatorWires_bramDin     I    32 reg
// EN_ppcMessageInput_put         I     1
// EN_ppcMessageOutput_get        I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkBRAMFeeder(CLK,
		    RST_N,

		    ppcMessageInput_put,
		    EN_ppcMessageInput_put,
		    RDY_ppcMessageInput_put,

		    EN_ppcMessageOutput_get,
		    ppcMessageOutput_get,
		    RDY_ppcMessageOutput_get,

		    bramInitiatorWires_bramRST,

		    bramInitiatorWires_bramAddr,

		    bramInitiatorWires_bramDout,

		    bramInitiatorWires_bramDin,

		    bramInitiatorWires_bramWEN,

		    bramInitiatorWires_bramEN,

		    CLK_bramInitiatorWires_bramCLK,
		    CLK_GATE_bramInitiatorWires_bramCLK);
  input  CLK;
  input  RST_N;

  // action method ppcMessageInput_put
  input  [31 : 0] ppcMessageInput_put;
  input  EN_ppcMessageInput_put;
  output RDY_ppcMessageInput_put;

  // actionvalue method ppcMessageOutput_get
  input  EN_ppcMessageOutput_get;
  output [31 : 0] ppcMessageOutput_get;
  output RDY_ppcMessageOutput_get;

  // value method bramInitiatorWires_bramRST
  output bramInitiatorWires_bramRST;

  // value method bramInitiatorWires_bramAddr
  output [13 : 0] bramInitiatorWires_bramAddr;

  // value method bramInitiatorWires_bramDout
  output [31 : 0] bramInitiatorWires_bramDout;

  // action method bramInitiatorWires_bramDin
  input  [31 : 0] bramInitiatorWires_bramDin;

  // value method bramInitiatorWires_bramWEN
  output [3 : 0] bramInitiatorWires_bramWEN;

  // value method bramInitiatorWires_bramEN
  output bramInitiatorWires_bramEN;

  // oscillator and gates for output clock CLK_bramInitiatorWires_bramCLK
  output CLK_bramInitiatorWires_bramCLK;
  output CLK_GATE_bramInitiatorWires_bramCLK;

  // signals for module outputs
  wire [31 : 0] bramInitiatorWires_bramDout, ppcMessageOutput_get;
  wire [13 : 0] bramInitiatorWires_bramAddr;
  wire [3 : 0] bramInitiatorWires_bramWEN;
  wire CLK_GATE_bramInitiatorWires_bramCLK,
       CLK_bramInitiatorWires_bramCLK,
       RDY_ppcMessageInput_put,
       RDY_ppcMessageOutput_get,
       bramInitiatorWires_bramEN,
       bramInitiatorWires_bramRST;

  // register bramInit_addr
  reg [13 : 0] bramInit_addr;
  reg [13 : 0] bramInit_addr$D_IN;
  wire bramInit_addr$EN;

  // register bramInit_dataOut
  reg [31 : 0] bramInit_dataOut;
  reg [31 : 0] bramInit_dataOut$D_IN;
  wire bramInit_dataOut$EN;

  // register bramInit_driveWEN
  reg bramInit_driveWEN;
  wire bramInit_driveWEN$D_IN, bramInit_driveWEN$EN;

  // register bramInit_state
  reg [2 : 0] bramInit_state;
  reg [2 : 0] bramInit_state$D_IN;
  wire bramInit_state$EN;

  // register partialRead
  reg [31 : 0] partialRead;
  wire [31 : 0] partialRead$D_IN;
  wire partialRead$EN;

  // register readPtr
  reg [7 : 0] readPtr;
  wire [7 : 0] readPtr$D_IN;
  wire readPtr$EN;

  // register state
  reg [3 : 0] state;
  reg [3 : 0] state$D_IN;
  wire state$EN;

  // register writePtr
  reg [7 : 0] writePtr;
  wire [7 : 0] writePtr$D_IN;
  wire writePtr$EN;

  // ports of submodule bramInit_readRespQ
  wire [31 : 0] bramInit_readRespQ$D_IN, bramInit_readRespQ$D_OUT;
  wire bramInit_readRespQ$CLR,
       bramInit_readRespQ$DEQ,
       bramInit_readRespQ$EMPTY_N,
       bramInit_readRespQ$ENQ,
       bramInit_readRespQ$FULL_N;

  // ports of submodule bramInit_readRespReserveQ
  wire bramInit_readRespReserveQ$CLR,
       bramInit_readRespReserveQ$DEQ,
       bramInit_readRespReserveQ$EMPTY_N,
       bramInit_readRespReserveQ$ENQ,
       bramInit_readRespReserveQ$FULL_N;

  // ports of submodule ppcInstQ
  wire [31 : 0] ppcInstQ$D_IN, ppcInstQ$D_OUT;
  wire ppcInstQ$CLR,
       ppcInstQ$DEQ,
       ppcInstQ$EMPTY_N,
       ppcInstQ$ENQ,
       ppcInstQ$FULL_N;

  // ports of submodule ppcInstQExt
  wire [31 : 0] ppcInstQExt$D_IN, ppcInstQExt$D_OUT;
  wire ppcInstQExt$CLR,
       ppcInstQExt$DEQ,
       ppcInstQExt$EMPTY_N,
       ppcInstQExt$ENQ,
       ppcInstQExt$FULL_N;

  // ports of submodule ppcMesgQ
  wire [31 : 0] ppcMesgQ$D_IN, ppcMesgQ$D_OUT;
  wire ppcMesgQ$CLR,
       ppcMesgQ$DEQ,
       ppcMesgQ$EMPTY_N,
       ppcMesgQ$ENQ,
       ppcMesgQ$FULL_N;

  // ports of submodule ppcMesgQExt
  wire [31 : 0] ppcMesgQExt$D_IN, ppcMesgQExt$D_OUT;
  wire ppcMesgQExt$CLR,
       ppcMesgQExt$DEQ,
       ppcMesgQExt$EMPTY_N,
       ppcMesgQExt$ENQ,
       ppcMesgQExt$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_mkConnectionGetPut,
       CAN_FIRE_RL_mkConnectionGetPut_1,
       WILL_FIRE_RL_bramInit_flopEnable,
       WILL_FIRE_RL_bramInit_handleRead,
       WILL_FIRE_RL_bramInit_handleReadWait,
       WILL_FIRE_RL_bramInit_handleWrite,
       WILL_FIRE_RL_inStartCheckRead,
       WILL_FIRE_RL_inStartCheckWrite,
       WILL_FIRE_RL_inStartPush,
       WILL_FIRE_RL_inStartRead,
       WILL_FIRE_RL_inStartTake,
       WILL_FIRE_RL_inStartWrite;

  // inputs to muxes for submodule ports
  wire [13 : 0] MUX_bramInit_addr$write_1__VAL_1,
		MUX_bramInit_addr$write_1__VAL_2,
		MUX_bramInit_addr$write_1__VAL_3,
		MUX_bramInit_addr$write_1__VAL_4;
  wire [3 : 0] MUX_state$write_1__VAL_1,
	       MUX_state$write_1__VAL_2,
	       MUX_state$write_1__VAL_3;
  wire MUX_bramInit_addr$write_1__SEL_1,
       MUX_bramInit_addr$write_1__SEL_2,
       MUX_bramInit_addr$write_1__SEL_3,
       MUX_bramInit_addr$write_1__SEL_4,
       MUX_bramInit_state$write_1__SEL_3,
       MUX_bramInit_state$write_1__SEL_4,
       MUX_bramInit_state$write_1__SEL_6;

  // remaining internal signals
  wire [7 : 0] readPtr_5_PLUS_2___d94,
	       writePtr_2_PLUS_1___d89,
	       writePtr_2_PLUS_2___d93,
	       x__h2327;
  wire [3 : 0] IF_ppcInstQ_notFull__7_THEN_2_ELSE_1___d95,
	       IF_ppcMesgQ_notEmpty__0_THEN_5_ELSE_1___d96;
  wire bramInit_readRespReserveQ_i_notEmpty__0_AND_NO_ETC___d63,
       bramInit_readRespReserveQ_i_notEmpty__0_AND_br_ETC___d36;

  // oscillator and gates for output clock CLK_bramInitiatorWires_bramCLK
  assign CLK_bramInitiatorWires_bramCLK = CLK ;
  assign CLK_GATE_bramInitiatorWires_bramCLK = 1'd1 ;

  // action method ppcMessageInput_put
  assign RDY_ppcMessageInput_put = ppcMesgQExt$FULL_N ;

  // actionvalue method ppcMessageOutput_get
  assign ppcMessageOutput_get = ppcInstQExt$D_OUT ;
  assign RDY_ppcMessageOutput_get = ppcInstQExt$EMPTY_N ;

  // value method bramInitiatorWires_bramRST
  assign bramInitiatorWires_bramRST = 1'd0 ;

  // value method bramInitiatorWires_bramAddr
  assign bramInitiatorWires_bramAddr = bramInit_addr ;

  // value method bramInitiatorWires_bramDout
  assign bramInitiatorWires_bramDout = bramInit_dataOut ;

  // value method bramInitiatorWires_bramWEN
  assign bramInitiatorWires_bramWEN =
	     (bramInit_state == 3'd2) ? 4'd15 : 4'd0 ;

  // value method bramInitiatorWires_bramEN
  assign bramInitiatorWires_bramEN = bramInit_state != 3'd0 ;

  // submodule bramInit_readRespQ
  FIFO2 #(.width(32'd32), .guarded(32'd1)) bramInit_readRespQ(.RST_N(RST_N),
							      .CLK(CLK),
							      .D_IN(bramInit_readRespQ$D_IN),
							      .ENQ(bramInit_readRespQ$ENQ),
							      .DEQ(bramInit_readRespQ$DEQ),
							      .CLR(bramInit_readRespQ$CLR),
							      .D_OUT(bramInit_readRespQ$D_OUT),
							      .FULL_N(bramInit_readRespQ$FULL_N),
							      .EMPTY_N(bramInit_readRespQ$EMPTY_N));

  // submodule bramInit_readRespReserveQ
  FIFO20 #(.guarded(32'd1)) bramInit_readRespReserveQ(.RST_N(RST_N),
						      .CLK(CLK),
						      .ENQ(bramInit_readRespReserveQ$ENQ),
						      .DEQ(bramInit_readRespReserveQ$DEQ),
						      .CLR(bramInit_readRespReserveQ$CLR),
						      .FULL_N(bramInit_readRespReserveQ$FULL_N),
						      .EMPTY_N(bramInit_readRespReserveQ$EMPTY_N));

  // submodule ppcInstQ
  FIFO2 #(.width(32'd32), .guarded(32'd1)) ppcInstQ(.RST_N(RST_N),
						    .CLK(CLK),
						    .D_IN(ppcInstQ$D_IN),
						    .ENQ(ppcInstQ$ENQ),
						    .DEQ(ppcInstQ$DEQ),
						    .CLR(ppcInstQ$CLR),
						    .D_OUT(ppcInstQ$D_OUT),
						    .FULL_N(ppcInstQ$FULL_N),
						    .EMPTY_N(ppcInstQ$EMPTY_N));

  // submodule ppcInstQExt
  FIFO2 #(.width(32'd32), .guarded(32'd1)) ppcInstQExt(.RST_N(RST_N),
						       .CLK(CLK),
						       .D_IN(ppcInstQExt$D_IN),
						       .ENQ(ppcInstQExt$ENQ),
						       .DEQ(ppcInstQExt$DEQ),
						       .CLR(ppcInstQExt$CLR),
						       .D_OUT(ppcInstQExt$D_OUT),
						       .FULL_N(ppcInstQExt$FULL_N),
						       .EMPTY_N(ppcInstQExt$EMPTY_N));

  // submodule ppcMesgQ
  FIFO2 #(.width(32'd32), .guarded(32'd1)) ppcMesgQ(.RST_N(RST_N),
						    .CLK(CLK),
						    .D_IN(ppcMesgQ$D_IN),
						    .ENQ(ppcMesgQ$ENQ),
						    .DEQ(ppcMesgQ$DEQ),
						    .CLR(ppcMesgQ$CLR),
						    .D_OUT(ppcMesgQ$D_OUT),
						    .FULL_N(ppcMesgQ$FULL_N),
						    .EMPTY_N(ppcMesgQ$EMPTY_N));

  // submodule ppcMesgQExt
  FIFO2 #(.width(32'd32), .guarded(32'd1)) ppcMesgQExt(.RST_N(RST_N),
						       .CLK(CLK),
						       .D_IN(ppcMesgQExt$D_IN),
						       .ENQ(ppcMesgQExt$ENQ),
						       .DEQ(ppcMesgQExt$DEQ),
						       .CLR(ppcMesgQExt$CLR),
						       .D_OUT(ppcMesgQExt$D_OUT),
						       .FULL_N(ppcMesgQExt$FULL_N),
						       .EMPTY_N(ppcMesgQExt$EMPTY_N));

  // rule RL_inStartTake
  assign WILL_FIRE_RL_inStartTake =
	     bramInit_state == 3'd1 && bramInit_readRespQ$EMPTY_N &&
	     bramInit_readRespReserveQ$EMPTY_N &&
	     ppcInstQ$FULL_N &&
	     state == 4'd4 ;

  // rule RL_inStartPush
  assign WILL_FIRE_RL_inStartPush = bramInit_state == 3'd1 && state == 4'd7 ;

  // rule RL_inStartCheckWrite
  assign WILL_FIRE_RL_inStartCheckWrite =
	     bramInit_state == 3'd1 && bramInit_readRespReserveQ$FULL_N &&
	     state == 4'd5 ;

  // rule RL_inStartRead
  assign WILL_FIRE_RL_inStartRead =
	     bramInit_readRespQ$EMPTY_N &&
	     bramInit_readRespReserveQ_i_notEmpty__0_AND_NO_ETC___d63 &&
	     state == 4'd3 ;

  // rule RL_inStartCheckRead
  assign WILL_FIRE_RL_inStartCheckRead =
	     bramInit_state == 3'd1 && bramInit_readRespReserveQ$FULL_N &&
	     state == 4'd2 ;

  // rule RL_bramInit_handleReadWait
  assign WILL_FIRE_RL_bramInit_handleReadWait =
	     bramInit_state == 3'd4 && !WILL_FIRE_RL_inStartRead &&
	     !WILL_FIRE_RL_inStartWrite ;

  // rule RL_mkConnectionGetPut
  assign CAN_FIRE_RL_mkConnectionGetPut =
	     ppcMesgQExt$EMPTY_N && ppcMesgQ$FULL_N ;

  // rule RL_inStartWrite
  assign WILL_FIRE_RL_inStartWrite =
	     bramInit_readRespQ$EMPTY_N &&
	     bramInit_readRespReserveQ_i_notEmpty__0_AND_br_ETC___d36 &&
	     state == 4'd6 ;

  // rule RL_mkConnectionGetPut_1
  assign CAN_FIRE_RL_mkConnectionGetPut_1 =
	     ppcInstQ$EMPTY_N && ppcInstQExt$FULL_N ;

  // rule RL_bramInit_handleWrite
  assign WILL_FIRE_RL_bramInit_handleWrite =
	     bramInit_state == 3'd2 && !WILL_FIRE_RL_inStartRead &&
	     !WILL_FIRE_RL_inStartWrite ;

  // rule RL_bramInit_handleRead
  assign WILL_FIRE_RL_bramInit_handleRead =
	     bramInit_readRespQ$FULL_N && bramInit_state == 3'd3 &&
	     !WILL_FIRE_RL_inStartRead &&
	     !WILL_FIRE_RL_inStartWrite ;

  // rule RL_bramInit_flopEnable
  assign WILL_FIRE_RL_bramInit_flopEnable =
	     bramInit_state == 3'd0 && !WILL_FIRE_RL_inStartRead &&
	     !WILL_FIRE_RL_inStartWrite ;

  // inputs to muxes for submodule ports
  assign MUX_bramInit_addr$write_1__SEL_1 =
	     WILL_FIRE_RL_inStartWrite && !bramInit_readRespQ$D_OUT[31] ;
  assign MUX_bramInit_addr$write_1__SEL_2 =
	     WILL_FIRE_RL_inStartRead && bramInit_readRespQ$D_OUT[31] ;
  assign MUX_bramInit_addr$write_1__SEL_3 =
	     WILL_FIRE_RL_inStartCheckWrite || WILL_FIRE_RL_inStartPush ;
  assign MUX_bramInit_addr$write_1__SEL_4 =
	     WILL_FIRE_RL_inStartCheckRead || WILL_FIRE_RL_inStartTake ;
  assign MUX_bramInit_state$write_1__SEL_3 =
	     WILL_FIRE_RL_bramInit_flopEnable ||
	     WILL_FIRE_RL_bramInit_handleRead ||
	     WILL_FIRE_RL_bramInit_handleWrite ;
  assign MUX_bramInit_state$write_1__SEL_4 =
	     WILL_FIRE_RL_inStartPush || WILL_FIRE_RL_inStartTake ;
  assign MUX_bramInit_state$write_1__SEL_6 =
	     WILL_FIRE_RL_inStartCheckRead || WILL_FIRE_RL_inStartCheckWrite ;
  assign MUX_bramInit_addr$write_1__VAL_1 =
	     { 6'd0, writePtr_2_PLUS_1___d89 } ;
  assign MUX_bramInit_addr$write_1__VAL_2 = { 6'd0, x__h2327 } ;
  assign MUX_bramInit_addr$write_1__VAL_3 = { 6'd0, writePtr } ;
  assign MUX_bramInit_addr$write_1__VAL_4 = { 6'd0, readPtr } ;
  assign MUX_state$write_1__VAL_1 =
	     ppcInstQ$FULL_N ?
	       IF_ppcInstQ_notFull__7_THEN_2_ELSE_1___d95 :
	       IF_ppcMesgQ_notEmpty__0_THEN_5_ELSE_1___d96 ;
  assign MUX_state$write_1__VAL_2 =
	     bramInit_readRespQ$D_OUT[31] ?
	       4'd4 :
	       IF_ppcMesgQ_notEmpty__0_THEN_5_ELSE_1___d96 ;
  assign MUX_state$write_1__VAL_3 =
	     bramInit_readRespQ$D_OUT[31] ?
	       IF_ppcInstQ_notFull__7_THEN_2_ELSE_1___d95 :
	       4'd7 ;

  // register bramInit_addr
  always@(MUX_bramInit_addr$write_1__SEL_1 or
	  MUX_bramInit_addr$write_1__VAL_1 or
	  MUX_bramInit_addr$write_1__SEL_2 or
	  MUX_bramInit_addr$write_1__VAL_2 or
	  MUX_bramInit_addr$write_1__SEL_3 or
	  MUX_bramInit_addr$write_1__VAL_3 or
	  MUX_bramInit_addr$write_1__SEL_4 or
	  MUX_bramInit_addr$write_1__VAL_4)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_bramInit_addr$write_1__SEL_1:
	  bramInit_addr$D_IN = MUX_bramInit_addr$write_1__VAL_1;
      MUX_bramInit_addr$write_1__SEL_2:
	  bramInit_addr$D_IN = MUX_bramInit_addr$write_1__VAL_2;
      MUX_bramInit_addr$write_1__SEL_3:
	  bramInit_addr$D_IN = MUX_bramInit_addr$write_1__VAL_3;
      MUX_bramInit_addr$write_1__SEL_4:
	  bramInit_addr$D_IN = MUX_bramInit_addr$write_1__VAL_4;
      default: bramInit_addr$D_IN =
		   14'b10101010101010 /* unspecified value */ ;
    endcase
  end
  assign bramInit_addr$EN =
	     WILL_FIRE_RL_inStartWrite && !bramInit_readRespQ$D_OUT[31] ||
	     WILL_FIRE_RL_inStartRead && bramInit_readRespQ$D_OUT[31] ||
	     WILL_FIRE_RL_inStartCheckWrite ||
	     WILL_FIRE_RL_inStartPush ||
	     WILL_FIRE_RL_inStartCheckRead ||
	     WILL_FIRE_RL_inStartTake ;

  // register bramInit_dataOut
  always@(MUX_bramInit_addr$write_1__SEL_1 or
	  ppcMesgQ$D_OUT or
	  WILL_FIRE_RL_inStartTake or WILL_FIRE_RL_inStartPush)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_bramInit_addr$write_1__SEL_1:
	  bramInit_dataOut$D_IN = ppcMesgQ$D_OUT;
      WILL_FIRE_RL_inStartTake: bramInit_dataOut$D_IN = 32'd0;
      WILL_FIRE_RL_inStartPush: bramInit_dataOut$D_IN = 32'hFFFFFFFF;
      default: bramInit_dataOut$D_IN = 32'hAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign bramInit_dataOut$EN =
	     WILL_FIRE_RL_inStartWrite && !bramInit_readRespQ$D_OUT[31] ||
	     WILL_FIRE_RL_inStartTake ||
	     WILL_FIRE_RL_inStartPush ;

  // register bramInit_driveWEN
  assign bramInit_driveWEN$D_IN = 1'b0 ;
  assign bramInit_driveWEN$EN = 1'b0 ;

  // register bramInit_state
  always@(MUX_bramInit_state$write_1__SEL_3 or
	  MUX_bramInit_addr$write_1__SEL_1 or
	  MUX_bramInit_state$write_1__SEL_4 or
	  WILL_FIRE_RL_bramInit_handleReadWait or
	  MUX_bramInit_addr$write_1__SEL_2 or
	  MUX_bramInit_state$write_1__SEL_6)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_bramInit_state$write_1__SEL_3: bramInit_state$D_IN = 3'd1;
      MUX_bramInit_addr$write_1__SEL_1 || MUX_bramInit_state$write_1__SEL_4:
	  bramInit_state$D_IN = 3'd2;
      WILL_FIRE_RL_bramInit_handleReadWait: bramInit_state$D_IN = 3'd3;
      MUX_bramInit_addr$write_1__SEL_2 || MUX_bramInit_state$write_1__SEL_6:
	  bramInit_state$D_IN = 3'd4;
      default: bramInit_state$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign bramInit_state$EN =
	     WILL_FIRE_RL_inStartWrite && !bramInit_readRespQ$D_OUT[31] ||
	     WILL_FIRE_RL_inStartRead && bramInit_readRespQ$D_OUT[31] ||
	     WILL_FIRE_RL_bramInit_flopEnable ||
	     WILL_FIRE_RL_bramInit_handleRead ||
	     WILL_FIRE_RL_bramInit_handleWrite ||
	     WILL_FIRE_RL_inStartPush ||
	     WILL_FIRE_RL_inStartTake ||
	     WILL_FIRE_RL_bramInit_handleReadWait ||
	     WILL_FIRE_RL_inStartCheckRead ||
	     WILL_FIRE_RL_inStartCheckWrite ;

  // register partialRead
  assign partialRead$D_IN = bramInit_readRespQ$D_OUT ;
  assign partialRead$EN = MUX_bramInit_addr$write_1__SEL_2 ;

  // register readPtr
  assign readPtr$D_IN =
	     (readPtr_5_PLUS_2___d94 <= 8'd31) ?
	       readPtr_5_PLUS_2___d94 :
	       8'd0 ;
  assign readPtr$EN = WILL_FIRE_RL_inStartTake ;

  // register state
  always@(state or
	  MUX_state$write_1__VAL_1 or
	  WILL_FIRE_RL_inStartRead or
	  MUX_state$write_1__VAL_2 or
	  WILL_FIRE_RL_inStartWrite or
	  MUX_state$write_1__VAL_3 or
	  WILL_FIRE_RL_inStartPush or
	  IF_ppcInstQ_notFull__7_THEN_2_ELSE_1___d95 or
	  WILL_FIRE_RL_inStartTake or
	  IF_ppcMesgQ_notEmpty__0_THEN_5_ELSE_1___d96 or
	  WILL_FIRE_RL_inStartCheckRead or WILL_FIRE_RL_inStartCheckWrite)
  begin
    case (1'b1) // synopsys parallel_case
      state == 4'd1: state$D_IN = MUX_state$write_1__VAL_1;
      WILL_FIRE_RL_inStartRead: state$D_IN = MUX_state$write_1__VAL_2;
      WILL_FIRE_RL_inStartWrite: state$D_IN = MUX_state$write_1__VAL_3;
      WILL_FIRE_RL_inStartPush:
	  state$D_IN = IF_ppcInstQ_notFull__7_THEN_2_ELSE_1___d95;
      WILL_FIRE_RL_inStartTake:
	  state$D_IN = IF_ppcMesgQ_notEmpty__0_THEN_5_ELSE_1___d96;
      WILL_FIRE_RL_inStartCheckRead: state$D_IN = 4'd3;
      WILL_FIRE_RL_inStartCheckWrite: state$D_IN = 4'd6;
      default: state$D_IN = 4'b1010 /* unspecified value */ ;
    endcase
  end
  assign state$EN =
	     state == 4'd1 || WILL_FIRE_RL_inStartRead ||
	     WILL_FIRE_RL_inStartWrite ||
	     WILL_FIRE_RL_inStartPush ||
	     WILL_FIRE_RL_inStartTake ||
	     WILL_FIRE_RL_inStartCheckRead ||
	     WILL_FIRE_RL_inStartCheckWrite ;

  // register writePtr
  assign writePtr$D_IN =
	     (writePtr_2_PLUS_2___d93 <= 8'd63) ?
	       writePtr_2_PLUS_2___d93 :
	       8'd32 ;
  assign writePtr$EN = WILL_FIRE_RL_inStartPush ;

  // submodule bramInit_readRespQ
  assign bramInit_readRespQ$D_IN = bramInitiatorWires_bramDin ;
  assign bramInit_readRespQ$DEQ =
	     WILL_FIRE_RL_inStartRead || WILL_FIRE_RL_inStartWrite ||
	     WILL_FIRE_RL_inStartTake ;
  assign bramInit_readRespQ$ENQ = WILL_FIRE_RL_bramInit_handleRead ;
  assign bramInit_readRespQ$CLR = 1'b0 ;

  // submodule bramInit_readRespReserveQ
  assign bramInit_readRespReserveQ$DEQ =
	     WILL_FIRE_RL_inStartRead || WILL_FIRE_RL_inStartWrite ||
	     WILL_FIRE_RL_inStartTake ;
  assign bramInit_readRespReserveQ$ENQ =
	     WILL_FIRE_RL_inStartRead && bramInit_readRespQ$D_OUT[31] ||
	     WILL_FIRE_RL_inStartCheckRead ||
	     WILL_FIRE_RL_inStartCheckWrite ;
  assign bramInit_readRespReserveQ$CLR = 1'b0 ;

  // submodule ppcInstQ
  assign ppcInstQ$D_IN = bramInit_readRespQ$D_OUT ;
  assign ppcInstQ$DEQ =
	     CAN_FIRE_RL_mkConnectionGetPut_1 && !WILL_FIRE_RL_inStartTake &&
	     !EN_ppcMessageOutput_get ;
  assign ppcInstQ$ENQ = WILL_FIRE_RL_inStartTake ;
  assign ppcInstQ$CLR = 1'b0 ;

  // submodule ppcInstQExt
  assign ppcInstQExt$D_IN = ppcInstQ$D_OUT ;
  assign ppcInstQExt$DEQ = EN_ppcMessageOutput_get ;
  assign ppcInstQExt$ENQ =
	     CAN_FIRE_RL_mkConnectionGetPut_1 && !WILL_FIRE_RL_inStartTake &&
	     !EN_ppcMessageOutput_get ;
  assign ppcInstQExt$CLR = 1'b0 ;

  // submodule ppcMesgQ
  assign ppcMesgQ$D_IN = ppcMesgQExt$D_OUT ;
  assign ppcMesgQ$DEQ = MUX_bramInit_addr$write_1__SEL_1 ;
  assign ppcMesgQ$ENQ =
	     CAN_FIRE_RL_mkConnectionGetPut && !EN_ppcMessageInput_put ;
  assign ppcMesgQ$CLR = 1'b0 ;

  // submodule ppcMesgQExt
  assign ppcMesgQExt$D_IN = ppcMessageInput_put ;
  assign ppcMesgQExt$DEQ =
	     CAN_FIRE_RL_mkConnectionGetPut && !EN_ppcMessageInput_put ;
  assign ppcMesgQExt$ENQ = EN_ppcMessageInput_put ;
  assign ppcMesgQExt$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_ppcInstQ_notFull__7_THEN_2_ELSE_1___d95 =
	     ppcInstQ$FULL_N ? 4'd2 : 4'd1 ;
  assign IF_ppcMesgQ_notEmpty__0_THEN_5_ELSE_1___d96 =
	     ppcMesgQ$EMPTY_N ? 4'd5 : 4'd1 ;
  assign bramInit_readRespReserveQ_i_notEmpty__0_AND_NO_ETC___d63 =
	     bramInit_readRespReserveQ$EMPTY_N &&
	     (!bramInit_readRespQ$D_OUT[31] ||
	      bramInit_state == 3'd1 && bramInit_readRespReserveQ$FULL_N) ;
  assign bramInit_readRespReserveQ_i_notEmpty__0_AND_br_ETC___d36 =
	     bramInit_readRespReserveQ$EMPTY_N &&
	     (bramInit_readRespQ$D_OUT[31] ||
	      bramInit_state == 3'd1 && ppcMesgQ$EMPTY_N) ;
  assign readPtr_5_PLUS_2___d94 = readPtr + 8'd2 ;
  assign writePtr_2_PLUS_1___d89 = writePtr + 8'd1 ;
  assign writePtr_2_PLUS_2___d93 = writePtr + 8'd2 ;
  assign x__h2327 = readPtr + 8'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        bramInit_addr <= `BSV_ASSIGNMENT_DELAY 14'd0;
	bramInit_dataOut <= `BSV_ASSIGNMENT_DELAY 32'd0;
	bramInit_driveWEN <= `BSV_ASSIGNMENT_DELAY 1'd1;
	bramInit_state <= `BSV_ASSIGNMENT_DELAY 3'd0;
	partialRead <= `BSV_ASSIGNMENT_DELAY 32'd0;
	readPtr <= `BSV_ASSIGNMENT_DELAY 8'd0;
	state <= `BSV_ASSIGNMENT_DELAY 4'd2;
	writePtr <= `BSV_ASSIGNMENT_DELAY 8'd32;
      end
    else
      begin
        if (bramInit_addr$EN)
	  bramInit_addr <= `BSV_ASSIGNMENT_DELAY bramInit_addr$D_IN;
	if (bramInit_dataOut$EN)
	  bramInit_dataOut <= `BSV_ASSIGNMENT_DELAY bramInit_dataOut$D_IN;
	if (bramInit_driveWEN$EN)
	  bramInit_driveWEN <= `BSV_ASSIGNMENT_DELAY bramInit_driveWEN$D_IN;
	if (bramInit_state$EN)
	  bramInit_state <= `BSV_ASSIGNMENT_DELAY bramInit_state$D_IN;
	if (partialRead$EN)
	  partialRead <= `BSV_ASSIGNMENT_DELAY partialRead$D_IN;
	if (readPtr$EN) readPtr <= `BSV_ASSIGNMENT_DELAY readPtr$D_IN;
	if (state$EN) state <= `BSV_ASSIGNMENT_DELAY state$D_IN;
	if (writePtr$EN) writePtr <= `BSV_ASSIGNMENT_DELAY writePtr$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    bramInit_addr = 14'h2AAA;
    bramInit_dataOut = 32'hAAAAAAAA;
    bramInit_driveWEN = 1'h0;
    bramInit_state = 3'h2;
    partialRead = 32'hAAAAAAAA;
    readPtr = 8'hAA;
    state = 4'hA;
    writePtr = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N)
      if (WILL_FIRE_RL_inStartPush)
	$display("BRAM: write [%d] = %h", writePtr, 32'hFFFFFFFF);
    if (RST_N)
      if (WILL_FIRE_RL_inStartWrite && !bramInit_readRespQ$D_OUT[31])
	$display("BRAM: write [%d] = %h",
		 writePtr_2_PLUS_1___d89,
		 ppcMesgQ$D_OUT);
    if (RST_N)
      if (WILL_FIRE_RL_inStartWrite && WILL_FIRE_RL_inStartTake)
	$display("Error: \"../src/BRAMFeeder.bsv\", line 174, column 8: (R0001)\n  Mutually exclusive rules RL_inStartWrite and RL_inStartTake fired in the\n  same clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkBRAMFeeder

