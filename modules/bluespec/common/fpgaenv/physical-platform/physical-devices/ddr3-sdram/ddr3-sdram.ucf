############################################################################
## 
##  Xilinx, Inc. 2006            www.xilinx.com 
##  Fri Dec 11 13:34:50 2009
##  Generated by MIG Version 3.3
##  
############################################################################
##  File name :       example_top.ucf
## 
##  Details :     Constraints file
##                    FPGA family:       virtex6
##                    FPGA:              xc6vlx240t-ff1156
##                    Speedgrade:        -1
##                    Design Entry:      VERILOG
##                    Frequency:         400 MHz
##                    Time Period:         2500 ps
##                    Design:            with Test bench
##                    No.Of Controllers: 1
##
############################################################################ 
##  Modifications for ML605 with LX240T FPGA (single clock design 800 Mbps)
##  Start with UCF file generated by MIG 3.3 (ISE 11.3 build L.68.3.0)
##  1. Delete all memory pin LOCS and replace with ML605 specific LOCS
##     A. MIG 3.3 design doesn't produce LOCS for ML605 board pin assignments
##        (see section "Location Constraints")
##  2. Delete "sda" and "scl" signals (not supported by MIG 3.3)
##  3. Board specific clocking and reset definitions. Default MIG 3.3 
##     example design assumes 2 clock inputs to design.  
##        - clk_ref to IDELAY_CTRL element (200 MHz input)
##        - sys_clk to PLL circuit (system clock input)
##     This design uses a single 200 MHz LVDS clock input to the top level
##     block. Modifications to HDL explained to example_top.v. FOr UCF file:
##        A. Top level use LVDS clock "sys_clk" input for 800 Mbps data rate. 
##        B. Delete clk_ref_p and clk_ref_n inputs (HDL and LOC constraints)
##        C. Comment out PERIOD constraint on "sys_clk_ibufg" (not used)
##        D. Change IOSTANDARD on sys_clk differential inputs to LVDS_25
##  4. Use CPU_RESET for sys_reset input (HDL code option defines reset polarity)      
##  5. Edit DCI_CASCADE line to define ML605 implementation. Note MIG 3.3
##     GUI doesn't permit definition, however manual edits are done here.
##  6. Comment out CONFIG_PROHIBIT lines (pins reserved for MIG)
##     Since this design has LOC'ed I/O don't need to reserve these pins.
##     If adding addition function to a design, leave CONFIG_PROHIBIT lines
##     in constraint file as these pins must not be used by other logic!
##  7. Add "dbg_display_driver.v" module LEDS for ML605 
##     A. GPIO_LED0  "ON" when memory test running and no errors
##     B. GPIO_LED1  "flashing" heartbeat divided down counter 
##     C. GPIO_LED2  "OFF" when no memory errors detected
##     D. GPIO_LED3  "ON" when calibration and initialization complete
##     E. IOSTANDARD for LEDS is LVCMOS25
##  8. Replace MIG 3.3 generated LOCS for reserved "NC" pins with ML605 specific LOCS:
##     A. RSYNC (OSERDES, IODELAY and BUFR) LOC assignments specific to ML605 design
##     B. CPT (OSERDES and IODELAY) DQS(7:0)LOC assignments specific to ML605 design
##     C. OCB monitor LOC assignments specific to ML605 design 
##        
############################################################################
# Timing constraints                                                        #
#  200 MHz (5ns) for IDELAY_CTRL and SYS_CLK                          #
############################################################################

## ML605 single clock design comment out "sys_clk_p" PERIOD constraint that follows.
## NET "sys_clk_p" TNM_NET = TNM_sys_clk;
## TIMESPEC "TS_sys_clk" = PERIOD "TNM_sys_clk" 2.5 ns;

NET    "m_llpi_phys_plat_clocks_device_crystalClocks_sys_clk_buf_O" TNM_NET = TNM_clk_ref2;
TIMESPEC "TS_clk_ref2" = PERIOD "TNM_clk_ref2" 5 ns;

# Constrain BUFR clocks used to synchronize data from IOB to fabric logic
# Note that ISE cannot infer this from other PERIOD constraints because
# of the use of OSERDES blocks in the BUFR clock generation path
#NET "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/clk_rsync[?]" TNM_NET = TNM_clk_rsync;
#TIMESPEC "TS_clk_rsync" = PERIOD "TNM_clk_rsync" 5 ns;

# Paths between DQ/DQS ISERDES.Q outputs and CLB flops clocked by falling 
# edge of BUFR will by design only be used if DYNCLKDIVSEL is asserted for 
# that particular flop. Mark this path as being a full-cycle, rather than 
# a half cycle path for timing purposes. NOTE: This constraint forces full-
# cycle timing to be applied globally for all rising->falling edge paths 
# in all resynchronizaton clock domains. If the user had modified the logic
# in the resync clock domain such that other rising->falling edge paths 
# exist, then constraint below should be modified to utilize pattern 
# matching to specific affect only the DQ/DQS ISERDES.Q outputs
#TIMEGRP "TG_clk_rsync_rise" = RISING  "TNM_clk_rsync";
#TIMEGRP "TG_clk_rsync_fall" = FALLING "TNM_clk_rsync";
#TIMESPEC "TS_clk_rsync_rise_to_fall" = 
#  FROM "TG_clk_rsync_rise" TO "TG_clk_rsync_fall" "TS_clk_ref2" * 2;


# Signal to select between controller and physical layer signals. Four divided by two clock
# cycles (8 memory clock cycles) are provided by design for the signal to settle down.
# Used only by the phy modules.
#INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_init/u_ff_phy_init_data_sel" TNM = "TNM_PHY_INIT_SEL";
#TIMESPEC "TS_MC_PHY_INIT_SEL" = FROM "TNM_PHY_INIT_SEL" TO FFS = "TS_clk_ref2"*4;  ## = "2.5ns * 4" ML605 single clock

disable = reg_sr_o;
disable = reg_sr_r;

# Temporary workaround to prevent tools from performing timing analysis on
# ck_p/ck_n feedback path through the MMCM to the MMCM.LOCK signal (which in
# turn is in reset logic within the CLB fabric). This analysis is not
# necessary because the MMCM.LOCK signal is synchronized to the BUFG clock
# before being used.

#NET "ddr2Wires_ddr3_ck_n" TIG;
#NET "ddr2Wires_ddr3_ck_p" TIG;
############################################################################
########################################################################
# Controller 0
# Memory Device: DDR3_SDRAM->SODIMMs->MT4JSF6464HY-1G1
# Data Width:     64
# Frequency:      400
# Time Period:      2500
# Data Mask:     1
########################################################################


################################################################################
# I/O STANDARDS
################################################################################

NET  "ddr2Wires_ddr3_dq[*]"                               IOSTANDARD = SSTL15_T_DCI;
NET  "ddr2Wires_ddr3_addr[*]"                             IOSTANDARD = SSTL15;
NET  "ddr2Wires_ddr3_ba[*]"                               IOSTANDARD = SSTL15;
NET  "ddr2Wires_ddr3_ras_n"                               IOSTANDARD = SSTL15;
NET  "ddr2Wires_ddr3_cas_n"                               IOSTANDARD = SSTL15;
NET  "ddr2Wires_ddr3_we_n"                                IOSTANDARD = SSTL15;
NET  "ddr2Wires_ddr3_reset_n"                             IOSTANDARD = SSTL15;
NET  "ddr2Wires_ddr3_cs_n"                                IOSTANDARD = SSTL15;
NET  "ddr2Wires_ddr3_odt"                                 IOSTANDARD = SSTL15;
NET  "ddr2Wires_ddr3_cke"                                 IOSTANDARD = SSTL15;
NET  "ddr2Wires_ddr3_dm[*]"                               IOSTANDARD = SSTL15;

## ML605 200 MHz LVDS oscillator - single input clock design (2.5V bank)
#NET  "sys_clk_p"                                IOSTANDARD = LVDS_25;
#NET  "sys_clk_n"                                IOSTANDARD = LVDS_25;

## ML605 CPU_RESET switch (1.5V bank)
#NET  "sys_rst"           IOSTANDARD = SSTL15;   

NET  "ddr2Wires_ddr3_dqs_p[*]"                            IOSTANDARD = DIFF_SSTL15_T_DCI;
NET  "ddr2Wires_ddr3_dqs_n[*]"                            IOSTANDARD = DIFF_SSTL15_T_DCI;
NET  "ddr2Wires_ddr3_ck_p"                             IOSTANDARD = DIFF_SSTL15;
NET  "ddr2Wires_ddr3_ck_n"                             IOSTANDARD = DIFF_SSTL15;

################################################################################
## DCI_CASCADING
## Syntax : CONFIG DCI_CASCADE = "<master> <slave1> <slave2> ..";
################################################################################
##   MIG 3.3 GUI does not permit selection of proper master DCI banks
##   Define ML605 DCI bank cascade function as implemented on the board
##      Bank 26 and Bank 36 have DCI support ( = DCI masters)
##      Bank 25 and Bank 35 do not have DCI support ( = DCI slaves)
###############################################################################
 
 CONFIG DCI_CASCADE = "26 25";
 CONFIG DCI_CASCADE = "36 35";

##################################################################################
# Location Constraints
##################################################################################
##
##  Note: Deleted MIG 3.3 generated DDR3 FPGA LOC assignments.
##        Replace MIG constraint file with ML605 specific SODIMM constraints below.
##        LOC constraints organized by BANK numbers, per schematics.
##        SODIMM part number = MT41JSF6464HY-1G1 (512MB)
##
#############################################
## Bank 35 DDR3 SODIMM I/F pin assignments 
## 3 data bytes:
#############################################
## Data Byte 0
NET "ddr2Wires_ddr3_dq[0]"     LOC = "J11";          
NET "ddr2Wires_ddr3_dq[1]"     LOC = "E13";          
NET "ddr2Wires_ddr3_dq[2]"     LOC = "F13";          
NET "ddr2Wires_ddr3_dq[3]"     LOC = "K11";          
NET "ddr2Wires_ddr3_dq[4]"     LOC = "L11";          
NET "ddr2Wires_ddr3_dq[5]"     LOC = "K13";          
NET "ddr2Wires_ddr3_dq[6]"     LOC = "K12";          
NET "ddr2Wires_ddr3_dq[7]"     LOC = "D11";  
NET "ddr2Wires_ddr3_dm[0]"     LOC = "E11";
NET "ddr2Wires_ddr3_dqs_p[0]"  LOC = "D12";     
NET "ddr2Wires_ddr3_dqs_n[0]"  LOC = "E12";
## Data Byte 1
NET  "ddr2Wires_ddr3_dq[8]"    LOC = "M13";          
NET  "ddr2Wires_ddr3_dq[9]"    LOC = "J14";          
NET  "ddr2Wires_ddr3_dq[10]"   LOC = "B13";          
NET  "ddr2Wires_ddr3_dq[11]"   LOC = "B12";          
NET  "ddr2Wires_ddr3_dq[12]"   LOC = "G10";          
NET  "ddr2Wires_ddr3_dq[13]"   LOC = "M11";          
NET  "ddr2Wires_ddr3_dq[14]"   LOC = "C12";          
NET  "ddr2Wires_ddr3_dq[15]"   LOC = "A11";
NET  "ddr2Wires_ddr3_dm[1]"    LOC = "B11";
NET  "ddr2Wires_ddr3_dqs_p[1]" LOC = "H12";          
NET  "ddr2Wires_ddr3_dqs_n[1]" LOC = "J12";
## Data Byte 2
NET  "ddr2Wires_ddr3_dq[16]"   LOC = "G11";          
NET  "ddr2Wires_ddr3_dq[17]"   LOC = "F11";          
NET  "ddr2Wires_ddr3_dq[18]"   LOC = "D14";          
NET  "ddr2Wires_ddr3_dq[19]"   LOC = "C14";          
NET  "ddr2Wires_ddr3_dq[20]"   LOC = "G12";          
NET  "ddr2Wires_ddr3_dq[21]"   LOC = "G13";          
NET  "ddr2Wires_ddr3_dq[22]"   LOC = "F14";          
NET  "ddr2Wires_ddr3_dq[23]"   LOC = "H14"; 
NET  "ddr2Wires_ddr3_dm[2]"    LOC = "E14";
NET  "ddr2Wires_ddr3_dqs_p[2]" LOC = "A13";          
NET  "ddr2Wires_ddr3_dqs_n[2]" LOC = "A14";
#############################################
## Bank 26 DDR3 SODIMM I/F pin assignments 
## 2 data bytes:
#############################################       
## Data Byte 3
NET  "ddr2Wires_ddr3_dq[24]"   LOC = "C19";
NET  "ddr2Wires_ddr3_dq[25]"   LOC = "G20";          
NET  "ddr2Wires_ddr3_dq[26]"   LOC = "E19";          
NET  "ddr2Wires_ddr3_dq[27]"   LOC = "F20";          
NET  "ddr2Wires_ddr3_dq[28]"   LOC = "A20";          
NET  "ddr2Wires_ddr3_dq[29]"   LOC = "A21";          
NET  "ddr2Wires_ddr3_dq[30]"   LOC = "E22";          
NET  "ddr2Wires_ddr3_dq[31]"   LOC = "E23";
NET  "ddr2Wires_ddr3_dm[3]"    LOC = "D19";
NET  "ddr2Wires_ddr3_dqs_p[3]" LOC = "H19";          
NET  "ddr2Wires_ddr3_dqs_n[3]" LOC = "H20";
## Data Byte 4
NET  "ddr2Wires_ddr3_dq[32]"   LOC = "G21";          
NET  "ddr2Wires_ddr3_dq[33]"   LOC = "B21";          
NET  "ddr2Wires_ddr3_dq[34]"   LOC = "A23";          
NET  "ddr2Wires_ddr3_dq[35]"   LOC = "A24";          
NET  "ddr2Wires_ddr3_dq[36]"   LOC = "C20";          
NET  "ddr2Wires_ddr3_dq[37]"   LOC = "D20";          
NET  "ddr2Wires_ddr3_dq[38]"   LOC = "J20";          
NET  "ddr2Wires_ddr3_dq[39]"   LOC = "G22";
NET  "ddr2Wires_ddr3_dm[4]"    LOC = "B22";
NET  "ddr2Wires_ddr3_dqs_p[4]" LOC = "B23";          
NET  "ddr2Wires_ddr3_dqs_n[4]" LOC = "C23";
#############################################
## Bank 24 DDR3 SODIMM I/F pin assignments 
## 3 data bytes:
#############################################
## Data Byte 5
NET  "ddr2Wires_ddr3_dq[40]"   LOC = "D26";          
NET  "ddr2Wires_ddr3_dq[41]"   LOC = "F26";          
NET  "ddr2Wires_ddr3_dq[42]"   LOC = "B26";          
NET  "ddr2Wires_ddr3_dq[43]"   LOC = "E26";          
NET  "ddr2Wires_ddr3_dq[44]"   LOC = "C24";          
NET  "ddr2Wires_ddr3_dq[45]"   LOC = "D25";          
NET  "ddr2Wires_ddr3_dq[46]"   LOC = "D27";          
NET  "ddr2Wires_ddr3_dq[47]"   LOC = "C25";
NET  "ddr2Wires_ddr3_dm[5]"    LOC = "A26";
NET  "ddr2Wires_ddr3_dqs_p[5]" LOC = "B25";          
NET  "ddr2Wires_ddr3_dqs_n[5]" LOC = "A25";
## Data Byte 6
NET  "ddr2Wires_ddr3_dq[48]"   LOC = "C27";          
NET  "ddr2Wires_ddr3_dq[49]"   LOC = "B28";          
NET  "ddr2Wires_ddr3_dq[50]"   LOC = "D29";          
NET  "ddr2Wires_ddr3_dq[51]"   LOC = "B27";          
NET  "ddr2Wires_ddr3_dq[52]"   LOC = "G27";          
NET  "ddr2Wires_ddr3_dq[53]"   LOC = "A28";          
NET  "ddr2Wires_ddr3_dq[54]"   LOC = "E24";          
NET  "ddr2Wires_ddr3_dq[55]"   LOC = "G25";
NET  "ddr2Wires_ddr3_dm[6]"    LOC = "A29";
NET  "ddr2Wires_ddr3_dqs_p[6]" LOC = "H27";          
NET  "ddr2Wires_ddr3_dqs_n[6]" LOC = "G28";
## Data Byte 7
NET  "ddr2Wires_ddr3_dq[56]"   LOC = "F28";          
NET  "ddr2Wires_ddr3_dq[57]"   LOC = "B31";          
NET  "ddr2Wires_ddr3_dq[58]"   LOC = "H29";          
NET  "ddr2Wires_ddr3_dq[59]"   LOC = "H28";          
NET  "ddr2Wires_ddr3_dq[60]"   LOC = "B30";          
NET  "ddr2Wires_ddr3_dq[61]"   LOC = "A30";          
NET  "ddr2Wires_ddr3_dq[62]"   LOC = "E29";          
NET  "ddr2Wires_ddr3_dq[63]"   LOC = "F29";
NET  "ddr2Wires_ddr3_dm[7]"    LOC = "A31";
NET  "ddr2Wires_ddr3_dqs_p[7]" LOC = "C30";          
NET  "ddr2Wires_ddr3_dqs_n[7]" LOC = "D30";
#############################################
## Bank 36 DDR3 SODIMM I/F pin assignments
## Address and Control:
#############################################
## Addresses: (LOCS for 512MB SODIMM only)
##
NET "ddr2Wires_ddr3_addr[12]"  LOC = "H15"; 
NET "ddr2Wires_ddr3_addr[11]"  LOC = "M15"; 
NET "ddr2Wires_ddr3_addr[10]"  LOC = "M16"; 
NET "ddr2Wires_ddr3_addr[9]"   LOC = "F15"; 
NET "ddr2Wires_ddr3_addr[8]"   LOC = "G15"; 
NET "ddr2Wires_ddr3_addr[7]"   LOC = "B15"; 
NET "ddr2Wires_ddr3_addr[6]"   LOC = "A15"; 
NET "ddr2Wires_ddr3_addr[5]"   LOC = "J17"; 
NET "ddr2Wires_ddr3_addr[4]"   LOC = "D16"; 
NET "ddr2Wires_ddr3_addr[3]"   LOC = "E16"; 
NET "ddr2Wires_ddr3_addr[2]"   LOC = "B16";  
NET "ddr2Wires_ddr3_addr[1]"   LOC = "A16"; 
NET "ddr2Wires_ddr3_addr[0]"   LOC = "L14"; 
## Bank addresses:
NET "ddr2Wires_ddr3_ba[2]"     LOC = "L15"; 
NET "ddr2Wires_ddr3_ba[1]"     LOC = "J19"; 
NET "ddr2Wires_ddr3_ba[0]"     LOC = "K19"; 
## Controls:
NET "ddr2Wires_ddr3_ras_n"     LOC = "L19"; 
NET "ddr2Wires_ddr3_cas_n"     LOC = "C17"; 
NET "ddr2Wires_ddr3_we_n" 	   LOC = "B17"; 
NET "ddr2Wires_ddr3_reset_n"   LOC = "E18"; 
NET "ddr2Wires_ddr3_cs_n"   LOC = "K18"; 
NET "ddr2Wires_ddr3_odt"    LOC = "F18"; 
NET "ddr2Wires_ddr3_cke"    LOC = "M18"; 
## FPGA differential clock output (400 MHz):
NET "ddr2Wires_ddr3_ck_p"   LOC = "G18"; 
NET "ddr2Wires_ddr3_ck_n"   LOC = "H18"; 
     
##
#########################################################
###  ML605 clocks and system reset inputs and GPIO LEDS
#########################################################
## 
#NET "sys_clk_p"     LOC = "J9"; 	# Epson 200 MHz LVDS oscillator P
#NET "sys_clk_n"     LOC = "H9"; 	# Epson 200 MHz LVDS oscillator N
#NET "sys_rst"       LOC = "H10";    # CPU_RESET switch (active high reset)           
         

#NET "led[0]"        LOC = "AC22";  # ML605 GPIO_LED0 = ON when test running, no errors     
#NET "led[1]"        LOC = "AC24";  # ML605 GPIO_LED1 = divided down CLK should be blinking
#NET "led[2]"        LOC = "AE22";  # ML605 GPIO_LED2 = error (should be OFF)
#NET "led[3]"        LOC = "AE23";  # ML605 GPIO_LED3 = ON when initialization and calibration complete
#NET "led[*]"        IOSTANDARD = LVCMOS25;


## ML605 (replace MIG 3.3 output with ML605 specific LOCS)

##################################################################################################
##The following locations must be reserved and cannot be used for external I/O because          ##
##the I/O elements associated with these sites (IODELAY, OSERDES, and associated routing)       ##
##are used to generate and route the clocks necessary for read data capture and synchronization ##
##to the core clock domain. These pins should not be routed out on the user's PCB               ##
##################################################################################################

##################################################################################################
##The logic of this pin is used internally to drive a BUFR in the column. This chosen pin must  ##
##be a clock pin capable of spanning to all of the banks containing data bytes in the particular##
##column. That is, all byte groups must be within +/- 1 bank of this pin. This pin cannot be    ##
##used for other functions and should not be connected externally. If a different pin is chosen,##
##he corresponding LOC constraint must also be changed.                                         ##
##################################################################################################

###############################################################################################
## Note: ML605 optional to comment out these lines. If design has more I/O than just MIG 3.3
##       example design, leave CONFIG PROHIBIT definitions in design to permit reservation of
##       these I/O pins for MIG use.
###############################################################################################

## CONFIG PROHIBIT = F19,G18;
##CONFIG PROHIBIT = C29,M12;


######################################################################################
##Place RSYNC OSERDES and IODELAY:                                                  ##
######################################################################################

##Site: C29 -- Bank 25
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col1.u_oserdes_rsync"
  LOC = "OLOGIC_X1Y139";
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col1.u_odelay_rsync"
  LOC = "IODELAY_X1Y139";

INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col1.u_bufr_rsync"
  LOC = "BUFR_X1Y6";

##Site: M12 -- Bank 35
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col0.u_oserdes_rsync"
  LOC = "OLOGIC_X2Y139";
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col0.u_odelay_rsync"
  LOC = "IODELAY_X2Y139";

INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col0.u_bufr_rsync"
  LOC = "BUFR_X2Y6";

##################################################################################################
##The logic of this pin is used internally to drive a BUFIO for the byte group. Any clock       ##
##capable pin in the same bank as the data byte group (DQS, DQ, DM if used) can be used for     ##
##this pin. This pin cannot be used for other functions and should not be connected externally. ##
##If a different pin is chosen, the corresponding LOC constraint must also be changed.          ##
##################################################################################################

##CONFIG PROHIBIT = B20,C13,C28,D24,F21,F25,K14,L13;

######################################################################################
##Place CPT OSERDES and IODELAY:                                                    ##
######################################################################################

##Site: C13 -- Bank 35
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[0].u_oserdes_cpt"
  LOC = "OLOGIC_X2Y137";
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[0].u_odelay_cpt"
  LOC = "IODELAY_X2Y137";

##Site: L13 -- Bank 35
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[1].u_oserdes_cpt"
  LOC = "OLOGIC_X2Y141";
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[1].u_odelay_cpt"
  LOC = "IODELAY_X2Y141";

##Site: K14 -- Bank 35
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[2].u_oserdes_cpt"
  LOC = "OLOGIC_X2Y143";
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[2].u_odelay_cpt"
  LOC = "IODELAY_X2Y143";

##Site: F21 -- Bank 26
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[3].u_oserdes_cpt"
  LOC = "OLOGIC_X1Y179";
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[3].u_odelay_cpt"
  LOC = "IODELAY_X1Y179";

##Site: B20 -- Bank 26
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[4].u_oserdes_cpt"
  LOC = "OLOGIC_X1Y181";
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[4].u_odelay_cpt"
  LOC = "IODELAY_X1Y181";

##Site: F25 -- Bank 25
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[5].u_oserdes_cpt"
  LOC = "OLOGIC_X1Y137";
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[5].u_odelay_cpt"
  LOC = "IODELAY_X1Y137";

##Site: C28 -- Bank 25
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[6].u_oserdes_cpt"
  LOC = "OLOGIC_X1Y141";
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[6].u_odelay_cpt"
  LOC = "IODELAY_X1Y141";

##Site: D24 -- Bank 25
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[7].u_oserdes_cpt"
  LOC = "OLOGIC_X1Y143";
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[7].u_odelay_cpt"
  LOC = "IODELAY_X1Y143";



NET      "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_data_io/gen_dqs[0].u_phy_dqs_iob/u_iobuf_dqs/split_buf_net" S;
NET      "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_data_io/gen_dqs[1].u_phy_dqs_iob/u_iobuf_dqs/split_buf_net" S;
NET      "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_data_io/gen_dqs[2].u_phy_dqs_iob/u_iobuf_dqs/split_buf_net" S;
NET      "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_data_io/gen_dqs[3].u_phy_dqs_iob/u_iobuf_dqs/split_buf_net" S;
NET      "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_data_io/gen_dqs[4].u_phy_dqs_iob/u_iobuf_dqs/split_buf_net" S;
NET      "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_data_io/gen_dqs[5].u_phy_dqs_iob/u_iobuf_dqs/split_buf_net" S;
NET      "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_data_io/gen_dqs[6].u_phy_dqs_iob/u_iobuf_dqs/split_buf_net" S;
NET      "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_data_io/gen_dqs[7].u_phy_dqs_iob/u_iobuf_dqs/split_buf_net" S;

######################################################################################
## MMCM_ADV CONSTRAINTS                                                             ##
######################################################################################

INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_infrastructure/u_mmcm_adv"      LOC = "MMCM_ADV_X0Y8"; #Banks 16, 26, 36
INST "*/gen_enable_ocb_mon.u_phy_ocb_mon_top/u_oserdes_ocb_mon" LOC = "OLOGIC_X2Y130";
INST "*/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/u_mmcm_clk_base" LOC = "MMCM_ADV_X0Y8"; #Banks 16, 26, 36



###########################################################################
##  ML605 additions
###########################################################################

#INST    "*/u_ddr3/*"                                    AREA_GROUP = "AG_ddr3";
#AREA_GROUP "AG_ddr3"                                    RANGE = SLICE_X58Y132:SLICE_X97Y196;

#LEAP TIGs

INST "*_ddr3_*_statusReg*"         TNM=TG_model_clk;
 
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_infrastructure/rstdiv0_sync_r*" TNM=TG_ram_clk;
INST "m_llpi_phys_plat_ddr3_device_dramController/u_ddr3/u_memc_ui_top/u_ui_top/ui_cmd0/app_rdy_r" TNM=TG_ram_clk;
INST "*_ddr3_*_syncResetQ/dGDeqPtr*"         TNM=TG_ram_clk;
INST "*_ddr3_*_syncResetQ/sGEnqPtr*"         TNM=TG_model_clk;
INST "*_ddr3_*_syncResetQ/dSyncReg1*"        TNM=TG_ram_clk;
INST "*_ddr3_*_syncResetQ/sSyncReg1*"        TNM=TG_model_clk;

INST "*_ddr3_*_syncRequestQ/Mram_fifoMem*"   TNM=TG_model_clk;
INST "*_ddr3_*_syncRequestQ/dDoutReg*"       TNM=TG_ram_clk;
INST "*_ddr3_*_syncRequestQ/dDoutReg*"       TIG;
INST "*_ddr3_*_syncRequestQ/dGDeqPtr*"       TNM=TG_ram_clk;
INST "*_ddr3_*_syncRequestQ/sGEnqPtr*"       TNM=TG_model_clk;
INST "*_ddr3_*_syncRequestQ/dSyncReg1*"      TNM=TG_ram_clk;
INST "*_ddr3_*_syncRequestQ/sSyncReg1*"      TNM=TG_model_clk;

INST "*_ddr3_*_syncWriteDataQ/Mram_fifoMem*" TNM=TG_model_clk;
INST "*_ddr3_*_syncWriteDataQ/dDoutReg*"     TNM=TG_ram_clk;
INST "*_ddr3_*_syncWriteDataQ/dDoutReg*"     TIG;
INST "*_ddr3_*_syncWriteDataQ/dGDeqPtr*"     TNM=TG_ram_clk;
INST "*_ddr3_*_syncWriteDataQ/sGEnqPtr*"     TNM=TG_model_clk;
INST "*_ddr3_*_syncWriteDataQ/dSyncReg1*"    TNM=TG_ram_clk;
INST "*_ddr3_*_syncWriteDataQ/sSyncReg1*"    TNM=TG_model_clk;

INST "*_ddr3_*_syncReadDataQ/Mram_fifoMem*"  TNM=TG_ram_clk;
INST "*_ddr3_*_syncReadDataQ/dDoutReg*"      TNM=TG_model_clk;
INST "*_ddr3_*_syncReadDataQ/dDoutReg*"      TIG;
INST "*_ddr3_*_syncReadDataQ/dGDeqPtr*"      TNM=TG_model_clk;
INST "*_ddr3_*_syncReadDataQ/sGEnqPtr*"      TNM=TG_ram_clk;
INST "*_ddr3_*_syncReadDataQ/dSyncReg1*"     TNM=TG_model_clk;
INST "*_ddr3_*_syncReadDataQ/sSyncReg1*"     TNM=TG_ram_clk;

## Add these when SRAM_DEBUG awb option is enabled
#INST "*_ddr3_*_syncStatus/sDataSyncIn*"      TNM=TG_ram_clk;
#INST "*_ddr3_*_syncStatus/dD_OUT*"           TNM=TG_model_clk;
#INST "*_ddr3_*_syncStatus/sync/sToggleReg*"  TNM=TG_ram_clk;
#INST "*_ddr3_*_syncStatus/sync/dSyncReg1*"   TNM=TG_model_clk;

TIMESPEC TS_model_clk_to_ram_clk=FROM TG_model_clk TO TG_ram_clk 5ns DATAPATHONLY;
TIMESPEC TS_ram_clk_to_model_clk=FROM TG_ram_clk TO TG_model_clk 5ns DATAPATHONLY;