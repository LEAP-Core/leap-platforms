///////////////////////////////////////////////////////////////////////////////
// (c) Copyright 2008 Xilinx, Inc. All rights reserved.
//
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
//
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
//
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
//
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// 
///////////////////////////////////////////////////////////////////////////////
//
//  IDLE_AND_VER_GEN
//
//
//  Description: the IDLE_AND_VER_GEN module generates idle sequences and
//               verification sequences for the Aurora channel.  The idle sequences
//               are constantly generated by a pseudorandom generator and a counter
//               to make the sequence Aurora compliant.  If the gen_ver signal is high,
//               verification symbols are added to the mix at appropriate intervals
//
//               This module supports 1 4-byte lane designs
//

`timescale 1 ns / 1 ps

module aurora_8b10b_v5_3_IDLE_AND_VER_GEN
(
    //Channel Init SM Interface
    GEN_VER,

    DID_VER,


    //Aurora Lane Interface
    GEN_A,
    GEN_K,
    GEN_R,
    GEN_V,


    //System Interface
    RESET,
    USER_CLK
);

`define DLY #1


//***********************************Port Declarations*******************************


    //Channel Init SM Interface
    input              GEN_VER;

    output             DID_VER;


    //Aurora Lane Interface
    output             GEN_A;
    output  [0:3]      GEN_K;
    output  [0:3]      GEN_R;
    output  [0:3]      GEN_V;


    //System Interface
    input              RESET;
    input              USER_CLK;


//*********************************External Register Declarations*********************

    reg                DID_VER;

//********************************Internal Register Declarations**********************
    reg     [0:3]      lfsr_reg;
    reg     [0:2]      down_count_r;
    reg     [0:2]      downcounter_r;
    reg                prev_cycle_gen_ver_r;

//*********************************Wire Declarations**********************************
    wire    [0:3]      gen_k_c;
    wire    [0:3]      gen_r_c;
    wire               ver_counter_c;
    wire    [0:3]      gen_k_flop_c;
    wire    [0:3]      gen_r_flop_c;
    wire               gen_a_flop_c;
    wire               downcounter_done_c;
    wire               gen_ver_edge_c;
    wire               recycle_gen_ver_c;
    wire               insert_ver_c;

//*********************************Main Body of Code**********************************


    //____________________________Random Pattern Generation_________________________

    // Use an LFSR to create pseudorandom patterns.  This is a 4-bit LFSR from
    // the Aurora 401.  Taps on bits 0 and 3 are XORed with the OR of bits 1:3
    // to make the input to the register.

    initial
        lfsr_reg = 0;

    always @(posedge USER_CLK) begin
        lfsr_reg[0] <= lfsr_reg[1];
        lfsr_reg[1] <= lfsr_reg[2];
        lfsr_reg[2] <= lfsr_reg[3];
        lfsr_reg[3] <= (lfsr_reg[0] ^ lfsr_reg[3] ^ (~| lfsr_reg[1:3]));
    end

    // A constants generator is used to limit the downcount range to values
    // between 3 and 6 (4 to 7 clocks, 16 to 28 bytes).

    initial
        down_count_r = 0;

    always @(posedge USER_CLK) begin
        case (lfsr_reg[1:3])
            3'b000: down_count_r <= 3;
            3'b001: down_count_r <= 4;
            3'b010: down_count_r <= 5;
            3'b011: down_count_r <= 6;
            3'b100: down_count_r <= 3;
            3'b101: down_count_r <= 4;
            3'b110: down_count_r <= 5;
            3'b111: down_count_r <= 6;
        endcase
    end

    // Use a downcounter to determine when A's should be added to the idle pattern.
    // Load the counter with the 3 least significant bits of the lfsr whenever the
    // counter reaches 0.

    initial
        downcounter_r = 0;

    always @(posedge USER_CLK) begin
        if (RESET) downcounter_r <= `DLY 0;
        else if (downcounter_done_c) downcounter_r <= `DLY down_count_r;
        else downcounter_r <= `DLY downcounter_r - 1;
    end

    assign downcounter_done_c = (downcounter_r == 3'b000);


    // The LFSR's pseudo random patterns are also used to generate the sequence of
    // K and R characters that make up the rest of the idle sequence.  Note that
    // R characters are used whenever K characters are not.

    assign gen_r_c =  lfsr_reg;
    assign gen_k_c = ~lfsr_reg;

    //_____________________Verification Sequence Generation________________________

    // Use a counter to generate the verification sequence every 64 bytes
    // (16 clocks), starting from when verification is enabled.

    always @(posedge USER_CLK)
        prev_cycle_gen_ver_r <= `DLY GEN_VER;


    // Detect the positive edge of the GEN_VER signal.

    assign gen_ver_edge_c = GEN_VER & !prev_cycle_gen_ver_r;


    // If GEN_VER is still high after generating a verification sequence,
    // indicate that the gen_ver signal can be generated again.

    assign recycle_gen_ver_c = DID_VER & GEN_VER;


    // Prime the verification counter SRL16 with a 1.  When this 1 reaches the end
    // of the register, it will become the gen_ver_word signal.  Prime the counter
    // only if there was a positive edge on GEN_VER to start the sequence, or if
    // the sequence has just ended and another must be generated.

    assign insert_ver_c = gen_ver_edge_c | recycle_gen_ver_c;


    // Main Body of the verification counter.  It is implemented as a shift register
    // made from an SRL16.  The register is 15 cycles long, and operates by
    // taking the 1 from the insert_ver_c signal and passing it though its stages.


    SRL16 #(.INIT(16'h0000)) ver_counter_i
    (
        .Q(ver_counter_c),
        .A0(1'b0),
        .A1(1'b1),
        .A2(1'b1),
        .A3(1'b1),
        .CLK(USER_CLK),
        .D(insert_ver_c)
    );


    // Generate the 4 bytes of the verification sequence on the cycle after
    // the verification counter reaches '15'.  Also signals that the verification
    // sequence has been generated.

    always @(posedge USER_CLK)
        DID_VER <= `DLY ver_counter_c;

    //_________________________________Output Signals_____________________________

    // Assert GEN_V in the LSBytes of each lane when DID_VER is asserted.  We use
    // a seperate register for each output to provide enough slack to allow the
    // Global logic to communicate with all lanes without causing timing problems.

    assign  GEN_V[0] = 1'b0;


    FD #(.INIT(1'b0)) gen_v_flop_1_i
    (
        .D(recycle_gen_ver_c),
        .C(USER_CLK),
        .Q(GEN_V[1])
    );


    FD #(.INIT(1'b0)) gen_v_flop_2_i
    (
        .D(recycle_gen_ver_c),
        .C(USER_CLK),
        .Q(GEN_V[2])
    );


    FD #(.INIT(1'b0)) gen_v_flop_3_i
    (
        .D(recycle_gen_ver_c),
        .C(USER_CLK),
        .Q(GEN_V[3])
    );


    // Assert GEN_A in the MSByte of each lane when the GEN_A downcounter reaches 0.
    // Note that the signal has a register for each output for the same reason as the
    // GEN_V signal.  GEN_A is ignored when it collides with other non-idle
    // generation requests at the Aurora Lane, but we qualify the signal with
    // the gen_ver_word_1_r signal so it does not overwrite the K used in the
    // MSByte of the first word of the Verification sequence.

    assign  gen_a_flop_c    =   downcounter_done_c & !recycle_gen_ver_c;



    FD #(.INIT(1'b0)) gen_a_flop_0_i
    (
        .D(gen_a_flop_c),
        .C(USER_CLK),
        .Q(GEN_A)
    );

    // Assert GEN_K in the MSByte when the lfsr dictates. Turn off the assertion if an
    // /A/ symbol is being generated on the byte.  Assert the signal without qualifications
    // if GEN_V is asserted.  Assert GEN_K in the LSBytes when the lfsr dictates.
    // There are no qualifications because only the GEN_R signal can collide with it, and
    // this is prevented by the way the gen_k_c signal is generated.  All other GEN signals
    // will override this signal at the AURORA_LANE.

    assign gen_k_flop_c[0] = (gen_k_c[0] & !downcounter_done_c) | recycle_gen_ver_c;



    FD #(.INIT(1'b0)) gen_k_flop_0_i
    (
        .D(gen_k_flop_c[0]),
        .C(USER_CLK),
        .Q(GEN_K[0])
    );

    assign gen_k_flop_c[1] = gen_k_c[1];


    FD #(.INIT(1'b0)) gen_k_flop_1_i
    (
        .D(gen_k_flop_c[1]),
        .C(USER_CLK),
        .Q(GEN_K[1])
    );

    assign gen_k_flop_c[2] = gen_k_c[2];


    FD #(.INIT(1'b0)) gen_k_flop_2_i
    (
        .D(gen_k_flop_c[2]),
        .C(USER_CLK),
        .Q(GEN_K[2])
    );

    assign gen_k_flop_c[3] = gen_k_c[3];


    FD #(.INIT(1'b0)) gen_k_flop_3_i
    (
        .D(gen_k_flop_c[3]),
        .C(USER_CLK),
        .Q(GEN_K[3])
    );


    // Assert GEN_R in the MSByte when the lfsr dictates.  Turn off the assertion if an
    // /A/ symbol, or the first verification word is being generated.  Assert GEN_R in the
    // LSByte when the lfsr dictates, with no qualifications (same reason as the GEN_K LSByte).

    assign gen_r_flop_c[0] = gen_r_c[0] & !downcounter_done_c & !recycle_gen_ver_c;



    FD #(.INIT(1'b0)) gen_r_flop_0_i
    (
        .D(gen_r_flop_c[0]),
        .C(USER_CLK),
        .Q(GEN_R[0])
    );

    assign gen_r_flop_c[1] = gen_r_c[1];


    FD #(.INIT(1'b0)) gen_r_flop_1_i
    (
        .D(gen_r_flop_c[1]),
        .C(USER_CLK),
        .Q(GEN_R[1])
    );

    assign gen_r_flop_c[2] = gen_r_c[2];


    FD #(.INIT(1'b0)) gen_r_flop_2_i
    (
        .D(gen_r_flop_c[2]),
        .C(USER_CLK),
        .Q(GEN_R[2])
    );

    assign gen_r_flop_c[3] = gen_r_c[3];


    FD #(.INIT(1'b0)) gen_r_flop_3_i
    (
        .D(gen_r_flop_c[3]),
        .C(USER_CLK),
        .Q(GEN_R[3])
    );

endmodule
