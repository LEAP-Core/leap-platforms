
///////////////////////////////////////////////////////////////////////////////
//
// Project:  Aurora 64B/66B
// Version:  version 7.3
// Company:  Xilinx
//
//
//
// (c) Copyright 2008 - 2009 Xilinx, Inc. All rights reserved.
//
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
//
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
//
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
//
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.

//
//
////////////////////////////////////////////////////////////////////////////////
// Design Name: aurora_64b66b_v7_3_WRAPPER
//
// Module aurora_64b66b_v7_3_WRAPPER
// Generated by Xilinx Architecture Wizard
// Written for synthesis tool: XST


// No of quads in design 1

`timescale 1ns / 1ps
(* core_generation_info = "aurora_64b66b_v7_3,aurora_64b66b_v7_3,{c_aurora_lanes=1, c_column_used=right, c_gt_clock_1=GTXQ0, c_gt_clock_2=None, c_gt_loc_1=1, c_gt_loc_10=X, c_gt_loc_11=X, c_gt_loc_12=X, c_gt_loc_13=X, c_gt_loc_14=X, c_gt_loc_15=X, c_gt_loc_16=X, c_gt_loc_17=X, c_gt_loc_18=X, c_gt_loc_19=X, c_gt_loc_2=X, c_gt_loc_20=X, c_gt_loc_21=X, c_gt_loc_22=X, c_gt_loc_23=X, c_gt_loc_24=X, c_gt_loc_25=X, c_gt_loc_26=X, c_gt_loc_27=X, c_gt_loc_28=X, c_gt_loc_29=X, c_gt_loc_3=X, c_gt_loc_30=X, c_gt_loc_31=X, c_gt_loc_32=X, c_gt_loc_33=X, c_gt_loc_34=X, c_gt_loc_35=X, c_gt_loc_36=X, c_gt_loc_37=X, c_gt_loc_38=X, c_gt_loc_39=X, c_gt_loc_4=X, c_gt_loc_40=X, c_gt_loc_41=X, c_gt_loc_42=X, c_gt_loc_43=X, c_gt_loc_44=X, c_gt_loc_45=X, c_gt_loc_46=X, c_gt_loc_47=X, c_gt_loc_48=X, c_gt_loc_5=X, c_gt_loc_6=X, c_gt_loc_7=X, c_gt_loc_8=X, c_gt_loc_9=X, c_lane_width=4, c_line_rate=10.0, c_gt_type=gtx, c_qpll=true, c_nfc=false, c_nfc_mode=IMM, c_refclk_frequency=156.25, c_simplex=false, c_simplex_mode=TX, c_stream=true, c_ufc=false, c_user_k=false,flow_mode=None, interface_mode=Streaming, dataflow_config=Duplex,}" *)

module aurora_64b66b_v7_3_WRAPPER #
(
    // Channel bond MASTER/SLAVE connection
    parameter CHAN_BOND_MODE_0      = 2'b00,
    parameter CHAN_BOND_MODE_1      = 2'b00,
// Simulation attributes
    parameter   SIM_GTXRESET_SPEEDUP=   "FALSE"      // Set to 1 to speed up sim reset 
)
`define DLY #1
(

   //----------------- Receive Ports - Channel Bonding Ports -----------------
    ENCHANSYNC_IN,
    CHBONDDONE_OUT,
    //RXLOSSOFSYNC indication
    RXLOSSOFSYNC_OUT,
//----------------- Receive Ports - Clock Correction Ports -----------------
    RXBUFERR_OUT,
    //----------------- Receive Ports - RX Data Path interface -----------------
    RXDATA_OUT,
    RXHEADER_OUT,
    RXRESET_IN,
    RXUSRCLK2_IN,
    //----- Receive Ports - RX Driver,OOB signalling,Coupling and Eq.,CDR ------
    RX1N_IN,
    RX1P_IN,
    //--------------- Receive Ports - RX Polarity Control Ports ----------------
    CHECK_POLARITY_IN,
    RXPOLARITY_IN,
    RX_NEG_OUT,
//------------------- Shared Ports - Tile and PLL Ports --------------------
    REFCLK1_IN,
    GTXRESET_IN,
    RESET,
    CHAN_BOND_RESET,
    PLLLKDET_OUT,
    POWERDOWN_IN,
    TXOUTCLK1_OUT,
    //-------------- Transmit Ports - 64b66b TX Header Ports --------------
    TXHEADER_IN,
    //---------------- Transmit Ports - TX Data Path interface -----------------
    TXDATA_IN,
    TXRESET_IN,
    TXUSRCLK_IN,
    TXUSRCLK2_IN,
    TXBUFERR_OUT,
    //--------------Data Valid Signals for Local Link
    TXDATAVALID_OUT,
    TXDATAVALID_SYMGEN_OUT,
    RXDATAVALID_OUT,
    //------------- Transmit Ports - TX Driver and OOB signalling --------------
    TX1N_OUT,
    TX1P_OUT,
   //---------------------- Loopback Port ----------------------
   LOOPBACK_IN,
   //---------------------- GTXE2 CHANNEL DRP Ports ----------------------
   DRPADDR_IN,
   DRP_CLK_IN,
   DRPDI_IN,
   DRPDO_OUT,
   DRPRDY_OUT,
   DRPEN_IN,
   DRPWE_IN,
   //---------------------- GTXE2 COMMON DRP Ports ----------------------
   QPLL_DRPADDR_IN,
   QPLL_DRPDI_IN,
   QPLL_DRPDO_OUT,
   QPLL_DRPRDY_OUT,
   QPLL_DRPEN_IN,
   QPLL_DRPWE_IN,
   TXCLK_LOCK,
   INIT_CLK,
   LINK_RESET_OUT
);
//***************************** Port Declarations *****************************
    //---------------------- Loopback and Powerdown Ports ----------------------
    input    [2:0]    LOOPBACK_IN;
    //----------------- Receive Ports - Channel Bonding Ports -----------------
    //----------------- Receive Ports - Channel Bonding Ports -----------------
 
    input             ENCHANSYNC_IN; 
    output            CHBONDDONE_OUT;
    output            RXLOSSOFSYNC_OUT;
    //----------------- Receive Ports - Clock Correction Ports -----------------
    output            RXBUFERR_OUT;
    //----------------- Receive Ports - RX Data Path interface -----------------
    output   [63:0]   RXDATA_OUT; 
    output   [1:0]    RXHEADER_OUT; 
    input             RXRESET_IN;
    input             RXUSRCLK2_IN;
    //----- Receive Ports - RX Driver,OOB signalling,Coupling and Eq.,CDR ------
 
    input             RX1N_IN;  
    input             RX1P_IN;  
    //--------------- Receive Ports - RX Polarity Control Ports ----------------
    input             CHECK_POLARITY_IN;
    input             RXPOLARITY_IN;
    output reg        RX_NEG_OUT;
    //------------------- Shared Ports - Tile and PLL Ports --------------------
    input             REFCLK1_IN;
    input             GTXRESET_IN;
    input             CHAN_BOND_RESET;
    output            PLLLKDET_OUT;
    output            TXOUTCLK1_OUT;
    input             POWERDOWN_IN;
    input             RESET;
    //-------------- Transmit Ports - 8b10b Encoder Control Ports --------------
    input    [1:0]    TXHEADER_IN; 
    //---------------- Transmit Ports - TX Data Path interface -----------------
    input    [63:0]   TXDATA_IN; 
    input             TXRESET_IN;
    output            TXBUFERR_OUT;
    input             TXUSRCLK_IN;
    input             TXUSRCLK2_IN;
    //------------- Transmit Ports - TX Driver and OOB signalling --------------
    output            TX1N_OUT;
    output            TX1P_OUT;
    output            TXDATAVALID_OUT;
    output            TXDATAVALID_SYMGEN_OUT;
    output            RXDATAVALID_OUT;
   //---------------------- GTXE2 CHANNEL DRP Ports ----------------------
    input   [8:0]   DRPADDR_IN;
    input           DRP_CLK_IN;
    input   [15:0]  DRPDI_IN;
    output  [15:0]  DRPDO_OUT;
    output          DRPRDY_OUT;
    input           DRPEN_IN;
    input           DRPWE_IN;
 
   //---------------------- GTXE2 COMMON DRP Ports ----------------------
    input   [7:0]   QPLL_DRPADDR_IN;
    input   [15:0]  QPLL_DRPDI_IN;
    output  [15:0]  QPLL_DRPDO_OUT;
    output          QPLL_DRPRDY_OUT;
    input           QPLL_DRPEN_IN;
    input           QPLL_DRPWE_IN;
    input             TXCLK_LOCK; 
    input             INIT_CLK;
    output            LINK_RESET_OUT;
//***************************** Wire Declarations *****************************
    // Ground and VCC signals
    wire                    tied_to_ground_i;
    wire    [63:0]          tied_to_ground_vec_i;
    // floating input port connection signals
    wire     [1:0]          open_rxbufstatus_i;
    wire                    open_txbufstatus_i;
    //  wire to output lock signal
    wire                    tx_plllkdet_i;
    wire                    rx_plllkdet_i;

    // Electrical idle reset logic signals
    wire                    resetdone_i;
    wire                    rx_resetdone_i;
    reg                     rx_resetdone_i2;
    wire                    tx_resetdone_i;

    // Channel Bonding 
    wire     [4:0]          chbondi;
   
    wire     [4:0]          chbondi_unused_i;
    wire     [4:0]          chbondo_to_slaves_i;
    wire                    state;
    wire                    data_valid_i;
    wire  [6:0]             txsequence_i;

    reg   [6:0]             txseq_counter_i;
    reg   [6:0]             datavalid_counter_i;
    reg   [10:0]            count_for_reset_r;
    reg   [2:0]             extend_reset_r;
    reg                     resetdone_r1;
    reg                     resetdone_r2;
    reg                     rx_reset_r1;
    reg                     rx_reset_r2;
    reg   [3:0]             reset_debounce_r;
    reg                     data_valid_r;
    wire  [1:0]             txheader_i;
    wire  [63:0]            scrambled_data_i;
     
    wire  [63:0]            new_rxdata_from_gtx_i;
    wire  [31:0]            rxdata_from_gtx_i;
    wire  [1:0]             new_rxheader_from_gtx_i;
    wire  [1:0]             rxheader_from_gtx_i;
    wire                    rxgearboxslip_i;
    wire                    new_rxheadervalid_i;
    wire                    rxheadervalid_i;
    wire                    new_rxdatavalid_i;
    wire                    rxdatavalid_i;
    wire                    open_rxheader_i;
    wire                    rxlossofsync_out_i;  
    wire  [63:0]            rxdata_to_fifo_i;
    wire                    rxrecclk_from_gtx_i;
    wire  [0:6]             not_connected_i;

    reg   [1:0]             rxheader_to_fifo_i2;
    reg   [63:0]            rxdata_to_fifo_i2;
    reg                     rxdatavalid_to_fifo_i2;
    reg   [1:0]             rxheader_to_fifo_i3;
    reg   [63:0]            rxdata_to_fifo_i3;
    reg                     rxdatavalid_to_fifo_i3;
    reg   [1:0]             rxheader_to_fifo_i4;
    reg   [63:0]            rxdata_to_fifo_i4;
    reg                     rxdatavalid_to_fifo_i4;
    reg   [1:0]             rxheader_to_fifo_i5;
    reg   [63:0]            rxdata_to_fifo_i5;
    reg                     rxdatavalid_to_fifo_i5;

    reg   [1:0]             rxheader_from_gtx_r;
    reg                     rx_polarity_r;
    reg                     rx_polarity_r2;
    reg                     check_polarity_r; 
    reg                     check_polarity_r2; 
 
    reg                     reset_blocksync_r;
    reg                     rx_resetdone_r1;                        
    reg                     rx_resetdone_r2;                        

    wire                    rxrecclk_32;
    wire                    rxrecclk_32_i;
    wire                    rxrecclk_64;
    wire                    rxrecclk_64_i;
    wire                    mmcm_locked_out_i;
    wire                    rxrecclk_to_pll_i;
    wire                    clkfbout_i;
  
    wire                    locked_i;
    wire                    gtx_rx_pcsreset_comb;
    wire                    rx_reset_i;
(* KEEP = "TRUE" *)  wire   clk_not_locked_i;
(* KEEP = "TRUE" *)  wire   enable_32_i;
(* KEEP = "TRUE" *)  wire   enable_64_i;

    wire                    gtx_reset_comb;
    reg   [1:0]             txheader_r;
    reg   [1:0]             tx_hdr_r;
 
    wire  [1:0]             rxbuferr_out_i;
    wire  [1:0]             link_reset_0_c;
    wire                    link_reset_c;

   wire                     gt_qpllclk_quad1_i;
   wire                     gt_qpllrefclk_quad1_i;
    wire                    gt_qplllock_i;
    wire                    qpllreset_i;
    wire                    gtxreset_i;
    reg                    rxdatavalid_to_fifo_i;
    reg  [1:0]             rxheader_to_fifo_i;
    wire                    tied_to_vcc_i;
    reg    [7:0]      reset_counter = 8'd0; 
//********************************* Main Body of Code**************************
    //-------------------------  Static signal Assigments ---------------------   
    assign tied_to_ground_i             = 1'b0;
    assign tied_to_ground_vec_i         = 64'h0000000000000000;
    assign tied_to_vcc_i             = 1'b1;

    // Assign lock signals

assign  PLLLKDET_OUT  = gt_qplllock_i;


    assign  RXBUFERR_OUT  =   rxbuferr_out_i[1]  || rxbuferr_out_i[0];

    assign  TXBUFERR_OUT  =  1'b0; 

    // Channel Bonding
    assign  chbondi_unused_i  = 5'b0;

    assign  chbondi = chbondi_unused_i;

    assign resetdone_i = rx_resetdone_i2 & tx_resetdone_i;

 
    //Special reset requirement for GTX GB
    always @(posedge TXUSRCLK2_IN)
    begin
         if(!resetdone_i)
         begin
              resetdone_r1 <= `DLY 1'b0;
              resetdone_r2 <= `DLY 1'b0;
         end
         else
         begin
              resetdone_r1 <= `DLY resetdone_i;
              resetdone_r2 <= `DLY resetdone_r1;
         end
    end

    assign gtx_reset_comb = !resetdone_r2 | RESET | TXRESET_IN;

    //------------------------- External Sequence Counter--------------------------
    always @(posedge TXUSRCLK2_IN)
    begin
        if(gtx_reset_comb | (txseq_counter_i == 32))
             txseq_counter_i <=  `DLY  7'd0;
        else txseq_counter_i <=  `DLY txseq_counter_i + 7'd1;
    end

    assign txsequence_i = txseq_counter_i;


    //Assign the Data Valid signal
    assign TXDATAVALID_OUT           = (txseq_counter_i != 28);

    //Assign TXDATAVALID to sym gen by accounting for the latency
    assign TXDATAVALID_SYMGEN_OUT    = (txseq_counter_i != 30);

    //_______________________________ Data Valid Signal ____ ________________________
    assign data_valid_i = (txseq_counter_i != 31);

    //#########################Clock Source########################
    BUFG rxrecclk_mmcm_bufg_i
    (
        .I                           (rxrecclk_from_gtx_i),
        .O                           (rxrecclk_to_pll_i)
    );

    aurora_64b66b_v7_3_clock_enable_generator rx_enable_generator_i
    (
          .RESET (mmcm_locked_out_i),
	  .USER_CLK(rxrecclk_to_pll_i),
	  .ENABLE_64(enable_64_i),
	  .ENABLE_32(enable_32_i)
    );

    
    assign mmcm_locked_out_i = (gt_qplllock_i );


    
 


    //----------------------------------RX reset signal for GTX--------------------------------
    
    always @(posedge rxrecclk_to_pll_i or negedge mmcm_locked_out_i)
    begin
         if(!mmcm_locked_out_i)
         begin
              rx_reset_r1 <= `DLY 1'b0;
              rx_reset_r2 <= `DLY 1'b0;
         end
         else if(enable_32_i)
         begin
              rx_reset_r1 <= `DLY RXRESET_IN;
              rx_reset_r2 <= `DLY rx_reset_r1;
         end
    end

    always @(posedge rxrecclk_to_pll_i)
    begin
         if(!resetdone_i)
         begin
              rx_resetdone_r1 <= `DLY 1'b0;
              rx_resetdone_r2 <= `DLY 1'b0;
         end
         else if(enable_32_i)
         begin
              rx_resetdone_r1 <= `DLY resetdone_i;
              rx_resetdone_r2 <= `DLY rx_resetdone_r1;
         end
    end

    assign  gtx_rx_pcsreset_comb =  !rx_resetdone_r2 | rx_reset_r2;

    assign  rx_reset_i           =  !mmcm_locked_out_i | rx_reset_r2 | link_reset_0_c[1];

    //Synchronize gtx_rx_pcsreset_comb with rxrecclk_64_i
    always @(posedge rxrecclk_to_pll_i)
    begin
          if(enable_32_i) reset_blocksync_r   <= `DLY gtx_rx_pcsreset_comb;             
    end

//*************************************************************************************************    
    //----------------------------------------------  ------------------------------------------   
    //*************************************************************************************************    

    // Upon configuration, GTXTXRESET and GTXRXRESET must be initiated in 
    // Sequential mode. If RESETOVRD and GTRESETSEL are already defaulted
    // to the above values, then all GT resets (CPLLRESET, QPLLRESET,
    // GTXTXRESET and GTXRXRESET) cannot be asserted until a minimum of 500ns 
    // after GSR deassertion.

    // If RESETOVRD and GTXRESETSEL are NOT defaulted to the above values, 
    // then user must do the following:
    // (a) wait a minimum of 500ns after GSR deassert
    // (b) set RESETOVRD and GTRESETSEL to 0
    // (c) wait another 300-500ns
    // (d) assert resets

      always @(posedge DRP_CLK_IN)
      begin
         if (reset_counter[7])
            reset_counter   <=   `DLY reset_counter;
         else
            reset_counter   <=   `DLY reset_counter + 1'b1;
      end

 

    //*************************************************************************************************    
    //----------------------------------------------  ------------------------------------------   
    //*************************************************************************************************    



    assign gtxreset_i = (!reset_counter[7]) ? 1'b0 : (!(gt_qplllock_i) );
    assign  qpllreset_i = GTXRESET_IN | link_reset_0_c[0];
 

    always @ (posedge TXUSRCLK2_IN)
    begin
        tx_hdr_r   <= `DLY TXHEADER_IN;
    end

  assign LINK_RESET_OUT =  link_reset_0_c[0];


    //*************************************************************************************************
    //-----------------------------------GTX INSTANCE-----------------------------------------------
    //*************************************************************************************************

aurora_64b66b_v7_3_MULTI_GT #
(
      .WRAPPER_SIM_GTRESET_SPEEDUP (SIM_GTXRESET_SPEEDUP)        // Set to 1 to speed up sim reset 
)
aurora_64b66b_v7_3_multi_gt_i
(
      .QPLL_DRPADDR_IN (QPLL_DRPADDR_IN),
      .QPLL_DRP_CLK_IN (DRP_CLK_IN),
      .QPLL_DRPDI_IN (QPLL_DRPDI_IN),
      .QPLL_DRPDO_OUT (QPLL_DRPDO_OUT),
      .QPLL_DRPEN_IN (QPLL_DRPEN_IN),
      .QPLL_DRPRDY_OUT (QPLL_DRPRDY_OUT),
      .QPLL_DRPWE_IN (QPLL_DRPWE_IN),
      .GT0_QPLLLOCK_OUT (gt_qplllock_i),
      .GT0_QPLLRESET_IN (qpllreset_i),
      .GT0_GTREFCLK0_COMMON_IN (REFCLK1_IN),
      .GT0_DRPADDR_IN(DRPADDR_IN),
      .GT0_DRP_CLK_IN(tied_to_ground_i),
      .GT0_DRPDI_IN(DRPDI_IN),
      .GT0_DRPDO_OUT(DRPDO_OUT),
      .GT0_DRPEN_IN(DRPEN_IN),
      .GT0_DRPRDY_OUT(DRPRDY_OUT),
      .GT0_DRPWE_IN(DRPWE_IN),
      .GT0_LOOPBACK_IN(LOOPBACK_IN),
      .GT0_RXUSERRDY_IN(mmcm_locked_out_i),
      .GT0_RXDATAVALID_OUT(rxdatavalid_i),
      .GT0_RXGEARBOXSLIP_IN(rxgearboxslip_i),
      .GT0_RXHEADER_OUT(rxheader_from_gtx_i),
      .GT0_RXHEADERVALID_OUT(rxheadervalid_i),
      .GT0_RXPRBSCNTRESET_IN(tied_to_ground_i),
      .GT0_RXPRBSSEL_IN_IN(tied_to_ground_vec_i[2:0]),
      .GT0_GTRXRESET_IN(gtxreset_i),
      .GT0_RXDATA_OUT(rxdata_from_gtx_i),
      .GT0_RXOUTCLK_OUT(rxrecclk_from_gtx_i),
      .GT0_RXPCSRESET_IN(tied_to_ground_i),
      .GT0_RXUSRCLK_IN(rxrecclk_to_pll_i),
      .GT0_RXUSRCLK2_IN(rxrecclk_to_pll_i),
      .GT0_GTXRXN_IN(RX1N_IN),
      .GT0_GTXRXP_IN(RX1P_IN),
//      .GT_RXCDRRESET_IN(tied_to_ground_i),
      .GT0_RXBUFRESET_IN(tied_to_ground_i),
      .GT0_RXRESETDONE_OUT(rx_resetdone_i),
//      .GT_TXPRECURSORINV_IN(tied_to_ground_i),
      .GT0_TXUSERRDY_IN(TXCLK_LOCK),
              //------------ Transmit Ports - 64b66b and 64b67b Gearbox Ports ------------
       .GT0_TXHEADER_IN(tx_hdr_r),
       .GT0_TXSEQUENCE_IN              (txsequence_i),
              //---------------- Transmit Ports - TX Data Path interface -----------------
        .GT0_GTTXRESET_IN               (gtxreset_i),
        .GT0_TXDATA_IN (scrambled_data_i),
       .GT0_TXOUTCLK_OUT(TXOUTCLK1_OUT),
       .GT0_TXPCSRESET_IN(tied_to_ground_i),
       .GT0_TXUSRCLK_IN(TXUSRCLK_IN),
       .GT0_TXUSRCLK2_IN(TXUSRCLK2_IN),
       .GT0_GTXTXN_OUT(TX1N_OUT),
       .GT0_GTXTXP_OUT(TX1P_OUT),
       .GT0_TXRESETDONE_OUT(tx_resetdone_i),
       .GT0_TXPRBSSEL_IN(tied_to_ground_vec_i[2:0]),
       .GT0_TXELECIDLE_IN(tied_to_ground_i)
);

 
   //#########################scrambler instantiation########################
    aurora_64b66b_v7_3_SCRAMBLER_64B66B #
    (
       .TX_DATA_WIDTH(64)
    )
    aurora_64b66b_v7_3_scrambler_64b66b_gtx0_i
    (
      // User Interface
       .UNSCRAMBLED_DATA_IN(TXDATA_IN),
       .SCRAMBLED_DATA_OUT(scrambled_data_i),
       .DATA_VALID_IN(data_valid_i),

       // System Interface
       .USER_CLK(TXUSRCLK2_IN),
       .SYSTEM_RESET(gtx_reset_comb)
    );

    
    //---------------------------Polarity Control Logic---------------------
    //Double synchronize CHECK_POLARITY_IN signal to account for domain crossing
    always @(posedge rxrecclk_to_pll_i)
    begin
          check_polarity_r   <= `DLY CHECK_POLARITY_IN;
          check_polarity_r2  <= `DLY check_polarity_r;
    end

    //Logic to account for polarity reversal
    always @(posedge rxrecclk_to_pll_i)
    begin
      if(check_polarity_r2 && (rxheader_from_gtx_i == 2'b01) && rxheadervalid_i)
          RX_NEG_OUT     <= `DLY   1'b1;
      else if(check_polarity_r2 && RX_NEG_OUT )
          RX_NEG_OUT     <= `DLY   1'b1;
      else
          RX_NEG_OUT     <= `DLY   1'b0;
    end

    //Finally double synchronize RX_POLARITY_IN signal and port map to RXPOLARITY0/1
    always @(posedge rxrecclk_to_pll_i)
    begin
          rx_polarity_r   <= `DLY RXPOLARITY_IN;
          rx_polarity_r2  <= `DLY rx_polarity_r;
    end

    always @(posedge rxrecclk_to_pll_i)
    if(enable_32_i)
    begin
          rxdatavalid_to_fifo_i  <= `DLY new_rxdatavalid_i;
          rxheader_to_fifo_i  <= `DLY new_rxheader_from_gtx_i;
    end

    //##########################descrambler instantiation########################
    aurora_64b66b_v7_3_DESCRAMBLER_64B66B #
    (
       .RX_DATA_WIDTH(64)
    )
    aurora_64b66b_v7_3_descrambler_64b66b_gtx0_i
    (
       // User Interface
       .SCRAMBLED_DATA_IN(new_rxdata_from_gtx_i),
       .UNSCRAMBLED_DATA_OUT(rxdata_to_fifo_i),
       .DATA_VALID_IN(new_rxdatavalid_i),

       // System Interface
       .USER_CLK(rxrecclk_to_pll_i),
       .ENABLE(enable_32_i),  
       .SYSTEM_RESET(!rxlossofsync_out_i)
    );

    //#########################block sync instantiation############################## 
    aurora_64b66b_v7_3_BLOCK_SYNC_SM #
    (
      .SH_CNT_MAX(64),
      .SH_INVALID_CNT_MAX(16)
    )
    aurora_64b66b_v7_3_block_sync_sm_gtx0_i
    (
      // User Interface
      .BLOCKSYNC_OUT(rxlossofsync_out_i),
      .RXGEARBOXSLIP_OUT(rxgearboxslip_i),
      .RXHEADER_IN(rxheader_from_gtx_i),
      .RXHEADERVALID_IN(rxheadervalid_i),

      // System Interface
      .USER_CLK(rxrecclk_to_pll_i),
      .SYSTEM_RESET(reset_blocksync_r)
    );

    always @ (posedge rxrecclk_to_pll_i)
    begin
        rx_resetdone_i2 <= `DLY rx_resetdone_i;
    end 

    aurora_64b66b_v7_3_WIDTH_CONVERSION  #
    (
      .INPUT_WIDTH(4),
      .OUTPUT_WIDTH(8)
    )
    aurora_64b66b_v7_3_width_conversion_i
    (
      .RESET(!rx_resetdone_i2),
      .ENABLE(enable_32_i),
      .USER_CLK(rxrecclk_to_pll_i),
      .HEADER_IN(rxheader_from_gtx_i),
      .HEADER_OUT(new_rxheader_from_gtx_i),
      .DATA_IN(rxdata_from_gtx_i),
      .DATA_OUT(new_rxdata_from_gtx_i),
      .DATAVALID_IN(rxdatavalid_i),
      .DATAVALID_OUT(new_rxdatavalid_i)
    );

    always @ (posedge rxrecclk_to_pll_i)
    begin
       rxheader_to_fifo_i2 <= `DLY rxheader_to_fifo_i;
       rxheader_to_fifo_i3 <= `DLY rxheader_to_fifo_i2;
       rxheader_to_fifo_i4 <= `DLY rxheader_to_fifo_i3;
       rxheader_to_fifo_i5 <= `DLY rxheader_to_fifo_i4;

       rxdatavalid_to_fifo_i2 <= `DLY rxdatavalid_to_fifo_i;
       rxdatavalid_to_fifo_i3 <= `DLY rxdatavalid_to_fifo_i2;
       rxdatavalid_to_fifo_i4 <= `DLY rxdatavalid_to_fifo_i3;
       rxdatavalid_to_fifo_i5 <= `DLY rxdatavalid_to_fifo_i4;

       rxdata_to_fifo_i2 <= `DLY rxdata_to_fifo_i;
       rxdata_to_fifo_i3 <= `DLY rxdata_to_fifo_i2;
       rxdata_to_fifo_i4 <= `DLY rxdata_to_fifo_i3;
       rxdata_to_fifo_i5 <= `DLY rxdata_to_fifo_i4;
    end

   
    //#########################CBCC module instantiation########################
    aurora_64b66b_v7_3_CLOCK_CORRECTION_CHANNEL_BONDING #
    (
      .CH_BOND_MAX_SKEW (2'b10),
      .CH_BOND_MODE   (CHAN_BOND_MODE_0)

    )
    cbcc_gtx0_i
    (

      //Write Interface 
      .GTX_RX_DATA_IN (rxdata_to_fifo_i5),
      .GTX_RX_DATAVALID_IN(rxdatavalid_to_fifo_i5),
      .GTX_RX_HEADER_IN(rxheader_to_fifo_i5),
      .WR_ENABLE(enable_32_i),
      .USER_CLK(rxrecclk_to_pll_i),
      .RXLOSSOFSYNC_IN(rxlossofsync_out_i),
      .ENCHANSYNC(ENCHANSYNC_IN),
      .CHAN_BOND_RESET(CHAN_BOND_RESET),

      //Read Interface
      .CC_RX_DATA_OUT(RXDATA_OUT),
      .CC_RX_BUF_STATUS_OUT(rxbuferr_out_i),
      .CC_RX_DATAVALID_OUT(RXDATAVALID_OUT),
      .CC_RX_HEADER_OUT(RXHEADER_OUT),
      .CC_RXLOSSOFSYNC_OUT(RXLOSSOFSYNC_OUT),

      .CHBONDI (chbondi),
      .CHBONDO (chbondo_to_slaves_i),
      .RXCHANISALIGNED(CHBONDDONE_OUT),
      .RESET(gtx_rx_pcsreset_comb),
      .RD_CLK (RXUSRCLK2_IN),
      .INIT_CLK (INIT_CLK),
      .LINK_RESET(link_reset_0_c)
    );
 


endmodule

