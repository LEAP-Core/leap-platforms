# -*-Python-*-

import os
import string
import sys

Import('*')


SUBDIRS = '@SUBDIRS@'
SURROGATE_BSVS = transform_string_list(SUBDIRS, None, '', '.bsv')

WRAPPER_BSVS = '@WRAPPER_BSVS@'
BSVS = '@BSVS@'
GEN_BSVS = '@GEN_BSVS@'

BSC = env['DEFS']['BSC']
BSC_FLAGS = env['DEFS']['BSC_FLAGS']
TMP_BSC_DIR = env['DEFS']['TMP_BSC_DIR']

##
## Two views of the same directory hierarchy.  One view with paths all relative
## to the root of the build tree.  The other relative to this directory.  We
## need both because when scons passes over the files to compute dependence and
## build rules the working directory changes to the directory holding each
## scons file.
##
## When the rules are finally executed to build the target the directory is
## always the root of the build tree.
##

ALL_DIRS_FROM_ROOT = env['DEFS']['ALL_HW_DIRS']
CWD_REL = env['DEFS']['CWD_REL']

ALL_BUILD_DIRS_FROM_ROOT = transform_string_list(ALL_DIRS_FROM_ROOT, ':', '', '/' + TMP_BSC_DIR)
ALL_LIB_DIRS_FROM_ROOT = ALL_DIRS_FROM_ROOT + ':' + ALL_BUILD_DIRS_FROM_ROOT

ALL_DIRS_FROM_CWD = ":".join([rebase_directory(x, CWD_REL) for x in clean_split(ALL_DIRS_FROM_ROOT)])
ALL_BUILD_DIRS_FROM_CWD = transform_string_list(ALL_DIRS_FROM_CWD, ':', '', '/' + TMP_BSC_DIR)
ALL_LIB_DIRS_FROM_CWD = ALL_DIRS_FROM_CWD + ':' + ALL_BUILD_DIRS_FROM_CWD

ROOT_DIR_HW_INC = env['DEFS']['ROOT_DIR_HW_INC']
ROOT_DIR_HW_INC_REL = rebase_directory(ROOT_DIR_HW_INC, CWD_REL)

##
## First compute dependence.  It runs pretty quickly so we do it every time
## without checking whether it is needed.  Knowing correct dependence before
## configuring the build rules makes the script simpler.
##
DERIVED = ''
if (SURROGATE_BSVS != ''):
    DERIVED = ' -derived "' + SURROGATE_BSVS + '"'
s = os.system('hasim-bsc-mkdepend -bdir ' + TMP_BSC_DIR + DERIVED + ' -p +:' + ROOT_DIR_HW_INC_REL + ':' + ROOT_DIR_HW_INC_REL + '/asim/provides:' + ALL_LIB_DIRS_FROM_CWD + ' ' + WRAPPER_BSVS + ' > .depends-bsv')
if (s & 0xffff) != 0:
    print 'Aborting due to dependence errors'
    sys.exit(1)

if not os.path.isdir(TMP_BSC_DIR):
    os.mkdir(TMP_BSC_DIR)

env.ParseDepends('.depends-bsv', must_exist = True)

##
## Cleaning?  There are a few somewhat unpredictable files generated by bsc
## depending on the source files.  Delete them here instead of parsing the
## source files and generating scons dependence rules.
##
if env.GetOption('clean'):
    os.system('cd ' + TMP_BSC_DIR + '; rm -f *.ba *.c *.h *.sched')



##
## Every generated .bo file also has a generated .bi and .log file.  This is
## how scons learns about them.
##
def emitter_bo(target, source, env):
    target.append(str(target[0]).replace('.bo', '.bi'))
    return target, source

def compile_bo_bsc_base(target):
    bdir = os.path.dirname(str(target[0]))
    lib_dirs = bsc_bdir_prune(ALL_LIB_DIRS_FROM_ROOT, ':', bdir)
    return BSC + ' ' + BSC_FLAGS + ' -p +:' + \
           ROOT_DIR_HW_INC + ':' + ROOT_DIR_HW_INC + '/asim/provides:' + \
           lib_dirs + ':' + TMP_BSC_DIR + ' -bdir ' + bdir + \
           ' -vdir ' + bdir + ' -simdir ' + bdir + ' -info-dir ' + bdir

def compile_bo(source, target, env, for_signature):
    cmd = compile_bo_bsc_base(target) + ' -D CONNECTION_SIZES_KNOWN ' + str(source[0])
    return cmd

bsc = Builder(generator = compile_bo, suffix = '.bo', src_suffix = '.bsv',
              emitter = emitter_bo)

# Builder for running just the compiler front end on a wrapper to find
# the dangling connections.  This will then be passed to hasim-connect
# to determine the required connection array sizes.
def compile_bsc_log(source, target, env, for_signature):
    ## Note -- we pipe through sed during the build to get rid of an extra
    ##         newline emitted by bsc's printType().  New compilers will make
    ##         this unnecessary.
    cmd = compile_bo_bsc_base(target) + ' -KILLexpanded ' + str(source[0]) + \
          ' 2>&1 | sed \':S;/{[^}]*$/{N;bS};s/\\n/\\\\n/g\' | tee ' + str(target[0]) + ' ; test $${PIPESTATUS[0]} -eq 0'
    return cmd

bsc_log = Builder(generator = compile_bsc_log, suffix = '.log', src_suffix = '.bsv')

# SUBD method for building generated .bsv file.  Can't use automatic
# suffix detection since source must be named explicitly.
bsc_subd = Builder(generator = compile_bo, emitter = emitter_bo)

env.Append(BUILDERS = {'BSC' : bsc, 'BSC_LOG' : bsc_log, 'BSC_SUBD' : bsc_subd})


BuildDir(TMP_BSC_DIR, '.', duplicate=0)

bsc_builds = []
for bsv in (BSVS + ' ' + GEN_BSVS).split():
    bsc_builds += env.BSC(TMP_BSC_DIR + '/' + bsv.replace('.bsv', ''))


wrapper_builds = []
for bsv in WRAPPER_BSVS.split():
    ##
    ## First pass just generates a log file to figure out cross synthesis
    ## boundary soft connection array sizes.
    ##
    log = env.BSC_LOG(TMP_BSC_DIR + '/' + bsv.replace('.bsv', ''))

    # Parse the log, generate a stub file
    stub_name = bsv.replace('.bsv', '_con_size.bsh')
    stub = env.Command(stub_name, log, 'hasim-connect --dynsize $SOURCE $TARGET')

    ##
    ## Now we are ready for the real build
    ##
    wrapper_bo = env.BSC(TMP_BSC_DIR + '/' + bsv.replace('.bsv', ''))
    Depends(wrapper_bo, stub)
    

    ##
    ## The mk_<wrapper>.v file is really built by the Wrapper() builder
    ## above.  Unfortunately, SCons doesn't appear to like having rules
    ## refer to multiple targets of the same build.  The following hack
    ## appears to work:  a command with no action and the Precious() call
    ## to keep SCons from deleting the .v file.  I tried an Alias()
    ## first, but that didn't work.
    ##
    w = env.Command(TMP_BSC_DIR + '/mk_' + bsv.replace('.bsv', '.v'),
                    TMP_BSC_DIR + '/' + bsv.replace('.bsv', '.bo'),
                    '')
    env.Precious(w)

    wrapper_builds += w

##
## Build subdirectories
##
APM_FILE = env['DEFS']['APM_FILE']

for s in SUBDIRS.split():
    env['DEFS']['CWD_REL'] = CWD_REL + '/' + s
    sd = SConscript([s + '/SConscript'])
    wrapper_builds += sd
    
    # Connection file derived from subdirectory build
    c = env.Command(s + '.bsv',
                    sd,
                    'hasim-connect ' + APM_FILE + ' $TARGET')

    # Build rule for the connection file
    env.BSC_SUBD(TMP_BSC_DIR + '/' + s + '.bo', c)


Return('wrapper_builds')
