# -*-Python-*-

import os
import re
import sys
import string
from model import  *
from synthesis_tool import  *
from post_synthesis_tool import *


SetOption('implicit_cache', 1)

defs = {
    'ALL_HW_DIRS'        : '@ALL_HW_DIRS@',
    'APM_FILE'           : '@APM_FILE@',
    'APM_NAME'           : '@APM_NAME@',
    'BDPI_CS'            : '@BDPI_CS@',
    'BSC'                : '@BSC@',
    'BSC_FLAGS_VERILOG'  : '@BSC_FLAGS_VERILOG@',
    'BSC_FLAGS_SIM'      : '@BSC_FLAGS_SIM@',
    'BUILD_DIR'          : '@BUILD_DIR@',
    'CONNECTION_SCRIPT'  : 'hasim-connect',
    'COST_TABLE'         : '@COST_TABLE@',
    'FPGA_PART_XILINX'   : '@FPGA_PART_XILINX@',
    'GIVEN_BAS'          : '@GIVEN_BAS@',
    'GIVEN_VHDS'         : '@GIVEN_VHDS@',
    'GIVEN_NGCS'         : '@GIVEN_NGCS@',
    'GIVEN_BMMS'         : '@GIVEN_BMMS@', 
    'GIVEN_ELFS'         : '@GIVEN_ELFS@',
    'GIVEN_CS'           : '@GIVEN_CS@',
    'GIVEN_VERILOGS'           : '@GIVEN_VERILOGS@',
    'GIVEN_ALTERAVS'     : '@GIVEN_ALTERA_VERILOGS@',
    'GIVEN_UCFS'         : '@GIVEN_UCFS@',
    'GIVEN_QSFS'         : '@GIVEN_QSFS@',
    'GIVEN_SDCS'         : '@GIVEN_SDCS@',
    'GIVEN_DATAS'        : '@GIVEN_DATAS@',
    'GEN_BAS'            : '@GEN_BAS@',
    'GEN_VS'             : '@GEN_VS@',
    'GEN_CXXS'           : 'schedule.cxx @GEN_CXXS@',
    'GEN_HS'             : 'schedule.h @GEN_HS@',
    'LDFLAGS'            : '-L /usr/lib64/curses -L /usr/lib/curses',
    'M5_BUILD_DIR'       : '@M5_BUILD_DIR@',    # Defined if m5 simulator is present
    'MAKE_ALL_TARGET'    : '@MAKE_ALL_TARGET@',
    'MAP_OPTIONS'        : '@MAP_OPTIONS@',
    'SYNTHESIS_TOOL'     : '@SYNTHESIS_TOOL@',
    'WORKSPACE_ROOT'     : '@MODEL_ROOT@',
    'ROOT_DIR_MODEL'     : '@ROOT_DIR_MODEL@',
    'ROOT_DIR_HW'        : '@ROOT_DIR_HW@',
    'ROOT_DIR_HW_INC'    : '@ROOT_DIR_HW_INC@',
    'ROOT_DIR_SW'        : '@ROOT_DIR_SW@',
    'ROOT_DIR_SW_INC'    : '@ROOT_DIR_SW_INC@',
    'SIMULATED_ISA'      : '@SIMULATED_ISA@',
    'SW_INC_DIRS'        : '@SW_INC_DIRS@',
    'SW_LIBS'            : '@SW_LIBS@',
    'SYNTH_TOP'          : '@SYNTH_TOP@',
    'SYNTH_WRAPPERS'     : '@SYNTH_WRAPPERS@',
    'SYNTH_BOUNDARIES'   : [@SYNTH_BOUNDARIES@],
    'TMP_BSC_DIR'        : '@TMP_BSC_DIR@',
    'TMP_XILINX_DIR'     : '@TMP_XILINX_DIR@',
    'WORKSPACE_ROOT'     : '@WORKSPACE_ROOT@',
}

# Propagate environment from external state
env = Environment(ENV = os.environ, DEFS = defs)
env['ENV']['SHELL'] = '/bin/sh'

env['DEFS']['ROOT_DIR_HW_MODEL'] = env['DEFS']['ROOT_DIR_HW'] + '/' + \
                                   env['DEFS']['ROOT_DIR_MODEL'];
env['DEFS']['ROOT_DIR_SW_MODEL'] = env['DEFS']['ROOT_DIR_SW'] + '/' + \
                                   env['DEFS']['ROOT_DIR_MODEL'];

utility_names = []

############################################################################
############################################################################
##
## Build the interface files first
##
############################################################################
############################################################################

if os.path.isfile('iface/SConstruct'):
    cmd = 'cd iface; scons'
    if env.GetOption('clean'):
        cmd += ' -c'
    s = os.system(cmd)
    if (s & 0xffff) != 0:
        print 'Aborting due to iface submodel errors'
        sys.exit(1)


############################################################################
############################################################################
##
## SCons configuration.
##
############################################################################
############################################################################

##
## env.Clone() is new as of 0.97.  It used to be called Copy().
##
import SCons.Environment
try:
    SCons.Environment.Environment.Clone
except AttributeError:
    SCons.Environment.Environment.Clone = SCons.Environment.Environment.Copy


############################################################################
############################################################################
##
## Build rules
##
############################################################################
############################################################################

# Bluespec compains about signature mismatches if we use this to avoid
# recompiling across synthesis boundaries.
#TargetSignatures('content')

APM_NAME = env['DEFS']['APM_NAME']
BSC = env['DEFS']['BSC']
BSC_FLAGS_SIM = env['DEFS']['BSC_FLAGS_SIM']
BSC_FLAGS_VERILOG = env['DEFS']['BSC_FLAGS_VERILOG']
LDFLAGS = env['DEFS']['LDFLAGS']
TMP_BSC_DIR = env['DEFS']['TMP_BSC_DIR']
WORKSPACE_ROOT = env['DEFS']['WORKSPACE_ROOT']

##
## DEBUG or OPT build?  User can override the workspace default rule by
## specifying either OPT=1 or DEBUG=1 on the scons command line.
##
if (int(ARGUMENTS.get('OPT', 0))):
    DEBUG = 0
elif (int(ARGUMENTS.get('DEBUG', 0))):
    DEBUG = 1
else:
    DEBUG = int(awb_resolver('-config=debug'))

##
## Enable tracing (software side debugging)?  Always enabled in debug mode.
##
TRACE = int(ARGUMENTS.get('TRACE', 0))
if (DEBUG):
    TRACE = 1

##
## Override Xilinx COST_TABLE with command line
##
env['DEFS']['COST_TABLE'] = ARGUMENTS.get('COST_TABLE', env['DEFS']['COST_TABLE'])

##
## Build events into model?
##
enable_events = int(ARGUMENTS.get('EVENTS', -1))
if (enable_events == -1):
    enable_events = int(awb_resolver('-config=events'))

if (enable_events == 0):
    bsc_events_flag = '-D HASIM_EVENTS_ENABLED=False'
    cpp_events_flag = ''
else:
    bsc_events_flag = '-D HASIM_EVENTS_ENABLED=True'
    cpp_events_flag = '-DHASIM_EVENTS_ENABLED'

BSC_FLAGS_VERILOG += ' ' + bsc_events_flag
env['DEFS']['BSC_FLAGS_VERILOG'] = BSC_FLAGS_VERILOG

BSC_FLAGS_SIM += ' ' + bsc_events_flag
env['DEFS']['BSC_FLAGS_SIM'] = BSC_FLAGS_SIM


ROOT_WRAPPER_SYNTH_ID = 'mk_' + env['DEFS']['ROOT_DIR_MODEL'] + '_Wrapper'

if env['DEFS']['GIVEN_CS'] != '':
    SW_EXE_OR_TARGET = env['DEFS']['ROOT_DIR_SW'] + '/obj/' + APM_NAME + '_sw.exe'
    SW_EXE = [SW_EXE_OR_TARGET]
else:
    SW_EXE_OR_TARGET = '$TARGET'
    SW_EXE = []


# What is the Bluespec compiler version?
bsc_version = 0

bsc_ostream = os.popen('bsc -verbose')
ver_regexp = re.compile('^Bluespec Compiler, version.*\(build ([0-9]+),')
for ln in bsc_ostream.readlines():
    m = ver_regexp.match(ln)
    if (m):
        bsc_version = int(m.group(1))
bsc_ostream.close()

if bsc_version == 0:
    print "Failed to get Bluespec compiler version"
    sys.exit(1)

env['DEFS']['BSC_VERSION'] = bsc_version


############################################################################
##
## Rules for HW subdirectory.  These are shared by all targets.
##
############################################################################
env['DEFS']['CWD_REL'] = env['DEFS']['ROOT_DIR_HW_MODEL']
env['DEFS']['BSC_FLAGS'] = env['DEFS']['BSC_FLAGS_VERILOG']
Export('env '+ " ".join(utility_names))
wrapper_v = SConscript([env['DEFS']['ROOT_DIR_HW_MODEL'] + '/SConscript'])

BuildDir(TMP_BSC_DIR, '.', duplicate=0)
env['ENV']['BUILD_DIR'] = env['DEFS']['BUILD_DIR']  # need to set the builddir for synplify


############################################################################
##
## Rules for building a Bluesim EXE.
##
############################################################################

bsc_sim_command = BSC + ' ' + BSC_FLAGS_SIM + ' ' + LDFLAGS + ' -o $TARGET'

if (env['DEFS']['BSC_VERSION'] >= 13013):
    # 2008.01.A compiler allows us to pass C++ arguments.
    if (DEBUG):
        bsc_sim_command += ' -Xc++ -O0'
    else:
        bsc_sim_command += ' -Xc++ -O1'

bsc_sim_command += \
    ' -sim -e ' + ROOT_WRAPPER_SYNTH_ID + ' -simdir ' + \
    TMP_BSC_DIR + ' ' + env['DEFS']['GEN_BAS'] + ' ' + env['DEFS']['GIVEN_BAS'] + \
    ' ' + env['DEFS']['BDPI_CS']

sbin = env.Command(
    TMP_BSC_DIR + '/' + APM_NAME + '_hw.exe',
    wrapper_v + clean_split(env['DEFS']['GIVEN_VERILOGS'], sep = ' ') + clean_split(env['DEFS']['BDPI_CS'], sep=' '),
    bsc_sim_command)

if env.GetOption('clean'):
    os.system('rm -rf .bsc')

# If we have bsc data files, copy them over to the .bsc directory 

if len(clean_split(env['DEFS']['GEN_VS'], sep = ' '))> 0:
   Copy(TMP_BSC_DIR, env['DEFS']['GIVEN_DATAS']) 

#
# The final step must leave a few well known names:
#   APM_NAME must be the software side, if there is one.  If there isn't, then
#   it must be the Bluesim image.
#
exe = env.Command(
    APM_NAME + '_hw.exe',
    sbin + SW_EXE,
    [ '@ln -fs $SOURCE $TARGET',
      '@ln -fs ' + SW_EXE_OR_TARGET + ' ' + APM_NAME,
      Delete(APM_NAME + '_hw.vexe'),
      Delete(APM_NAME + '_hw.errinfo') ])

env.Alias('exe', exe)



############################################################################
##
## Rules for building a Verilog simulation vexe
##
############################################################################

vexe_gen_command = \
    BSC + ' ' + BSC_FLAGS_VERILOG + ' -vdir ' + env['DEFS']['ROOT_DIR_HW'] + '/' + env['DEFS']['ROOT_DIR_MODEL'] + '/' + env['DEFS']['TMP_BSC_DIR'] + \
    ' -o $TARGET -verilog -e ' + ROOT_WRAPPER_SYNTH_ID + \
    ' $SOURCES ' + env['DEFS']['GIVEN_BAS']

vbin = env.Command(
    TMP_BSC_DIR + '/' + APM_NAME + '_hw.vexe',
    clean_split(env['DEFS']['GEN_VS'], sep = ' ') + clean_split(env['DEFS']['GIVEN_VERILOGS'], sep = ' ') + clean_split(env['DEFS']['GIVEN_VHDS'], sep = ' ')  + clean_split(env['DEFS']['BDPI_CS'], sep=' '),
    [ vexe_gen_command,
      Delete('directc.sft') ])


vexe = env.Command(
    APM_NAME + '_hw.vexe',
    vbin + SW_EXE,
    [ '@echo "#!/bin/sh" > $TARGET',
      '@echo "./$SOURCE +bscvcd \$*" >> $TARGET',
      '@chmod a+x $TARGET',
      '@ln -fs ' + SW_EXE_OR_TARGET + ' ' + APM_NAME,
      Delete(APM_NAME + '_hw.exe'),
      Delete(APM_NAME + '_hw.errinfo') ])

env.Alias('vexe', vexe)



############################################################################
##
## Rules for building a Xilinx bit image
##
############################################################################

TMP_XILINX_DIR = env['DEFS']['TMP_XILINX_DIR']
XILINX_APM_NAME = TMP_XILINX_DIR + '/' + APM_NAME

SYNTH_TOP = env['DEFS']['SYNTH_TOP']
XILINX_SYNTH_TOP = TMP_XILINX_DIR + '/' + SYNTH_TOP

FPGA_PART_XILINX = env['DEFS']['FPGA_PART_XILINX']

wrapper_builds = []

moduleList = ModuleList(env, ARGUMENTS)

#moduleList.dump()                      

Synthesize(moduleList)

print "finish configuring Synthesize \n"
#moduleList.dump()                      

PostSynthesize(moduleList)

print "finish configuring PostSynthesize \n"
#moduleList.dump()


# Use a cached post par ncd to guide map and par?  This is off by default since
# the smart guide option can make place & route fail when it otherwise would have
# worked.  It doesn't always improve run time, either.  To turn on smart guide
# either define the environment variable USE_SMARTGUIDE or set
# USE_SMARTGUIDE on the scons command line to a non-zero value.

# smartguide_cache_dir = env['DEFS']['WORKSPACE_ROOT'] + '/var/xilinx_ncd'
# smartguide_cache_file = APM_NAME + '_par.ncd'
# if not os.path.isdir(smartguide_cache_dir):
#     os.mkdir(smartguide_cache_dir)

# if ((int(ARGUMENTS.get('USE_SMARTGUIDE', 0)) or env['ENV'].has_key('USE_SMARTGUIDE')) and
#     (FindFile(APM_NAME + '_par.ncd', [smartguide_cache_dir]) != None)):
#     smartguide = ' -smartguide ' +  smartguide_cache_dir + '/' + smartguide_cache_file
# else:
#     smartguide = ''


# # Map
# xilinx_map = env.Command(
#     [ XILINX_APM_NAME + '_map.ncd', XILINX_APM_NAME + '.pcf' ],
#     moduleList.getAllDependencies('NGD'),
#     [ Delete(XILINX_APM_NAME + '_map.map'),
#       Delete(XILINX_APM_NAME + '_map.mrp'),
#       Delete(XILINX_APM_NAME + '_map.ncd'),
#       Delete(XILINX_APM_NAME + '_map.ngm'),
#       Delete(XILINX_APM_NAME + '_map.psr'),
#       'map -cm balanced -timing ' + smartguide + ' -t ' + env['DEFS']['COST_TABLE'] + ' ' +  env['DEFS']['MAP_OPTIONS'] + ' -logic_opt on -ol high -register_duplication -retiming on -pr b -c 100 -p ' + FPGA_PART_XILINX + ' -o $TARGET $SOURCE ' + XILINX_APM_NAME + '.pcf' ])

# Clean(xilinx_map, TMP_XILINX_DIR + '/xilinx_device_details.xml')




# # Place and route
# xilinx_par = env.Command(
#     XILINX_APM_NAME + '_par.ncd',
#     xilinx_map,
#     [ Delete(XILINX_APM_NAME + '_par.pad'),
#       Delete(XILINX_APM_NAME + '_par.par'),
#       Delete(XILINX_APM_NAME + '_par.ptwx'),
#       Delete(XILINX_APM_NAME + '_par.unroutes'),
#       Delete(XILINX_APM_NAME + '_par.xpi'),
#       Delete(XILINX_APM_NAME + '_par_pad.csv'),
#       Delete(XILINX_APM_NAME + '_par_pad.txt'),
#       'par -w -ol high ' + smartguide + ' -t ' + env['DEFS']['COST_TABLE'] + ' ' + XILINX_APM_NAME + '_map.ncd $TARGET ' + XILINX_APM_NAME + '.pcf',
#       Copy(smartguide_cache_dir + '/' + smartguide_cache_file, '$TARGET') ])


# # Generate the FPGA timing report -- this report isn't built by default.  Use
# # the "timing" target to generate it
# xilinx_trce = env.Command(
#     XILINX_APM_NAME + '_par.twr',
#     [ xilinx_par, XILINX_APM_NAME + '.pcf' ],
#     'trce -e 100 $SOURCES -o $TARGET')



# if len(env['DEFS']['GIVEN_ELFS']) != 0:
#     elf = ' -bd ' + str.join(' -bd ',clean_split(env['DEFS']['GIVEN_ELFS'], sep = ' '))
# else:
#     elf = ''




# # Generate the FPGA image
# xilinx_bit = env.Command(
#     XILINX_APM_NAME + '_par.bit',
#     [ 'config/' + APM_NAME + '.ut', xilinx_par],
#     [ Delete('config/signature.sh'),
#       'bitgen ' + elf + ' -f $SOURCES $TARGET ' + XILINX_APM_NAME + '.pcf' ])

# Depends(xilinx_bit, clean_split(env['DEFS']['GIVEN_ELFS'], sep = ' '));

# # Generate the signature for the FPGA image
# signature = env.Command(
#     'config/signature.sh',
#     xilinx_bit,
#     [ '@echo \'#!/bin/sh\' > $TARGET',
#       '@echo signature=\\"' + APM_NAME + '-`md5sum $SOURCE | sed \'s/ .*//\'`\\" >> $TARGET' ])

# #
# # The final step must leave a few files in well-known locations since they are
# # used by the run scripts.  APM_NAME is the software side, if there is one.
# #
# loader = env.Command(
#     APM_NAME + '_hw.errinfo',
#     signature + SW_EXE + xilinx_trce,
#     [ '@ln -fs ' + SW_EXE_OR_TARGET + ' ' + APM_NAME,
#       Delete(APM_NAME + '_hw.exe'),
#       Delete(APM_NAME + '_hw.vexe'),
#       '@echo "++++++++++++ Post-Place & Route ++++++++"',
#       '@' + awb_resolver('tools/scripts/hasim-xilinx-summary') + ' ' +
#           XILINX_APM_NAME + '_map.map ' +
#           XILINX_APM_NAME + '_par.par ' +
#           APM_NAME + '_hw.errinfo' ])
      
env.Alias('bit', moduleList.topModule.moduleDependency['LOADER'])
# env.Alias('bit', loader)


##
## Clean up a few extra files not described in the build rules
##
if env.GetOption('clean'):
    os.system('cd ' + TMP_XILINX_DIR + '; rm -f ' + APM_NAME + '*')
    os.system('rm -f APM_NAME')


############################################################################
##
## Rules for building the software side.  Invoke scripts in subdirectories
## to define the objects needing to be built.  The final link is defined
## here.
##
############################################################################

def host_defs():
    hostos = one_line_cmd('uname -s')
    hostmachine = one_line_cmd('uname -m')

    if (hostos == 'FreeBSD'):
        hflags = '-DHOST_FREEBSD'
    else:
        hflags = '-DHOST_LINUX'
        if (hostmachine == 'ia64'):
            hflags += ' -DHOST_LINUX_IA64'
        else:
            hflags += ' -DHOST_LINUX_X86'

    return hflags


if SW_EXE != []:
    inc_paths = clean_split(env['DEFS']['SW_INC_DIRS'], sep = ' ')
    libs = clean_split(env['DEFS']['SW_LIBS'], sep = ' ')
    cc_flags = host_defs()
    cc_flags += ' ' + cpp_events_flag
    if (DEBUG):
        cc_flags += ' -DASIM_ENABLE_ASSERTIONS'
    if (TRACE):
        cc_flags += ' -DASIM_ENABLE_TRACE'
    cc_flags += ' -DAPM_NAME=\\"' + APM_NAME + '\\"'

    ##
    ## These will be defined if the m5 simulator is part of the model
    ##
    M5_BUILD_DIR = env['DEFS']['M5_BUILD_DIR'] 
    if (M5_BUILD_DIR != ''):
        # m5 needs Python library
        inc_paths += [ os.path.join(sys.exec_prefix, 'include', 'python' + sys.version[:3]) ]
        python_zip = os.path.join(awb_resolver(M5_BUILD_DIR), 'm5py.zip')

        cc_flags += ' -DTRACING_ON=1'
        if (env['DEFS']['SIMULATED_ISA'] != ''):
            cc_flags += ' -DTHE_ISA=' + env['DEFS']['SIMULATED_ISA'] + '_ISA'

        if (DEBUG):
            cc_flags += ' -DDEBUG'
            # Swap the optimized m5 library for a debugging one
            tmp_libs = []
            for lib in libs:
                if (os.path.basename(lib) == 'libm5_opt.a'):
                    tmp_libs += [ os.path.join(os.path.dirname(lib), 'libm5_debug.a') ]
                else:
                    tmp_libs += [ lib ]
            libs = tmp_libs

    if (DEBUG):
        copt_flags = '-ggdb3 '
    else:
        copt_flags = '-g -O2 '

    # CPPPATH defines both gcc include path and dependence path for
    # SCons.  The '#' forces paths to be relative to the root of the build.
    sw_env = env.Clone(CCFLAGS = copt_flags + cc_flags,
                       LINKFLAGS = copt_flags,
                       CPPPATH = [ '#/' + env['DEFS']['ROOT_DIR_SW_INC'],
                                   '#/' + env['DEFS']['ROOT_DIR_HW_MODEL'],
                                   '#/iface/build/include',
                                   '.' ] + inc_paths)

    sw_env['DEFS']['CWD_REL'] = sw_env['DEFS']['ROOT_DIR_SW_MODEL']

    Export('sw_env '+ " ".join(utility_names))
    sw_build_dir = sw_env['DEFS']['ROOT_DIR_SW'] + '/obj'
    sw_objects = SConscript([env['DEFS']['ROOT_DIR_SW_MODEL'] + '/SConscript'],
                            build_dir = sw_build_dir,
                            duplicate = 0)

    sw_libpath = [ '.' ]
    sw_link_libs = [ 'pthread' ]

    sw_link_tgt = SW_EXE


    ##
    ## m5 needs libz, libmysqlclient and Python library
    ##
    if (M5_BUILD_DIR != ''):
        sw_link_libs += [ 'z' ]

        if (os.path.exists(os.path.join(sys.exec_prefix, 'lib' , 'libmysqlclient.a'))):
            sw_link_libs += [ 'mysqlclient' ]
        elif (os.path.exists(os.path.join(sys.exec_prefix, 'lib', 'mysql' , 'libmysqlclient.a'))):
            sw_link_libs += [ 'mysqlclient' ]

        # m5 needs python
        sw_libpath += [ os.path.join(sys.exec_prefix, 'lib') ]
        sw_link_libs += [ 'python' + sys.version[:3] ]

        # m5 links a temporary file then adds Python code
        sw_link_tgt = [ SW_EXE[0] + '.no_python' ]


    ##
    ## Put libs on the list of objects twice as a hack to work around the
    ## inability to specify the order of %library declarations across separate
    ## awb files.  Unix ld only searches libraries in command line order.
    ##
    sw_exe = sw_env.Program(sw_link_tgt, sw_objects + libs + libs, LIBPATH=sw_libpath, LIBS=sw_link_libs)

    if (M5_BUILD_DIR != ''):
        ##
        ## Define a simple SCons builder to concatenate files.  Used to append the
        ## Python zip archive to the executable.
        ##
        concat_builder = Builder(action = Action(['cat $SOURCES > $TARGET',
                                                  'chmod +x $TARGET']))
        sw_env.Append(BUILDERS = { 'Concat' : concat_builder })

        # Append Python code to the binary
        sw_exe = sw_env.Concat(SW_EXE, [ sw_exe, python_zip ])

############################################################################
############################################################################

##
## Set a default target
##
if (env['DEFS']['MAKE_ALL_TARGET'] != ''):
    Default(env['DEFS']['MAKE_ALL_TARGET'])
else:
    Default(exe)
