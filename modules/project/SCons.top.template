# -*-Python-*-

import os
import re
import sys
import string

SetOption('implicit_cache', 1)

defs = {
    'ALL_HW_DIRS'        : '@ALL_HW_DIRS@',
    'APM_FILE'           : '@APM_FILE@',
    'APM_NAME'           : '@APM_NAME@',
    'BDPI_CS'            : '@BDPI_CS@',
    'BSC'                : '@BSC@',
    'BSC_FLAGS_VERILOG'  : '@BSC_FLAGS_VERILOG@',
    'BSC_FLAGS_SIM'      : '@BSC_FLAGS_SIM@',
    'BUILD_DIR'          : '@BUILD_DIR@',
    'CONNECTION_SCRIPT'  : 'hasim-connect',
    'COST_TABLE'         : '@COST_TABLE@',
    'FPGA_PART_XILINX'   : '@FPGA_PART_XILINX@',
    'GIVEN_BAS'          : '@GIVEN_BAS@',
    'GIVEN_VHDS'         : '@GIVEN_VHDS@',
    'GIVEN_NGCS'         : '@GIVEN_NGCS@',
    'GIVEN_BMMS'         : '@GIVEN_BMMS@', 
    'GIVEN_ELFS'         : '@GIVEN_ELFS@',
    'GIVEN_CS'           : '@GIVEN_CS@',
    'GIVEN_VERILOGS'     : '@GIVEN_VERILOGS@',
    'GIVEN_UCFS'         : '@GIVEN_UCFS@',
    'GIVEN_SDCS'         : '@GIVEN_SDCS@',
    'GEN_BAS'            : '@GEN_BAS@',
    'GEN_VS'             : '@GEN_VS@',
    'GEN_CXXS'           : 'schedule.cxx @GEN_CXXS@',
    'GEN_HS'             : 'schedule.h @GEN_HS@',
    'LDFLAGS'            : '-L /usr/lib64/curses -L /usr/lib/curses',
    'M5_BUILD_DIR'       : '@M5_BUILD_DIR@',    # Defined if m5 simulator is present
    'MAKE_ALL_TARGET'    : '@MAKE_ALL_TARGET@',
    'MAP_OPTIONS'        : '@MAP_OPTIONS@',
    'SYNTHESIS_TOOL'     : '@SYNTHESIS_TOOL@',
    'WORKSPACE_ROOT'     : '@MODEL_ROOT@',
    'ROOT_DIR_MODEL'     : '@ROOT_DIR_MODEL@',
    'ROOT_DIR_HW'        : '@ROOT_DIR_HW@',
    'ROOT_DIR_HW_INC'    : '@ROOT_DIR_HW_INC@',
    'ROOT_DIR_SW'        : '@ROOT_DIR_SW@',
    'ROOT_DIR_SW_INC'    : '@ROOT_DIR_SW_INC@',
    'SIMULATED_ISA'      : '@SIMULATED_ISA@',
    'SW_INC_DIRS'        : '@SW_INC_DIRS@',
    'SW_LIBS'            : '@SW_LIBS@',
    'SYNTH_TOP'          : '@SYNTH_TOP@',
    'SYNTH_WRAPPERS'     : '@SYNTH_WRAPPERS@',
    'TMP_BSC_DIR'        : '@TMP_BSC_DIR@',
    'TMP_XILINX_DIR'     : '@TMP_XILINX_DIR@',
    'WORKSPACE_ROOT'     : '@WORKSPACE_ROOT@',
}

# Propagate environment from external state
env = Environment(ENV = os.environ, DEFS = defs)
env['ENV']['SHELL'] = '/bin/sh'

env['DEFS']['ROOT_DIR_HW_MODEL'] = env['DEFS']['ROOT_DIR_HW'] + '/' + \
                                   env['DEFS']['ROOT_DIR_MODEL'];
env['DEFS']['ROOT_DIR_SW_MODEL'] = env['DEFS']['ROOT_DIR_SW'] + '/' + \
                                   env['DEFS']['ROOT_DIR_MODEL'];

############################################################################
############################################################################
##
## Build the interface files first
##
############################################################################
############################################################################

if os.path.isfile('iface/SConstruct'):
    cmd = 'cd iface; scons'
    if env.GetOption('clean'):
        cmd += ' -c'
    s = os.system(cmd)
    if (s & 0xffff) != 0:
        print 'Aborting due to iface submodel errors'
        sys.exit(1)

############################################################################
############################################################################
##
## Utility functions used in this module and in submodules
##
############################################################################
############################################################################

utility_names = []

##
## clean_split --
##     Split a string into a list using specified separator (default ':'),
##     dropping empty entries.
##
utility_names.append('clean_split')
def clean_split(list, sep=':'):
    return [x for x in list.split(sep) if x != '' ]

##
## rebase_directory --
##     Rebase directory (d) that is a reference relative to the root build
##     directory, returning a result relative to cwd.  cwd must also be
##     relative to the root build directory.
##
utility_names.append('rebase_directory')
def rebase_directory(d, cwd):
    d = clean_split(d, sep='/')
    cwd = clean_split(cwd, sep='/')

    for x in cwd:
        if (len(d) == 0 or d[0] != x):
            d.insert(0, '..')
        else:
            d.pop(0)

    if (len(d) == 0): d = [ '.' ]
    return '/'.join(d)

##
## transform_string_list --
##     Interpret incoming string (str) as a list of substrings separated by (sep).
##     Add (prefix) and (suffix) to each substring and return a modified string.
##
utility_names.append('transform_string_list')
def transform_string_list(str, sep, prefix, suffix):
    if (sep == None):
        sep = ' '
    t = [ prefix + a + suffix for a in clean_split(str, sep) ]
    return string.join(t, sep)


##
## As of Bluespec 2008.11.C the -bdir target is put at the head of the search path
## and the compiler complains about duplicate path entries.
##
## This code removes the local build target from the search path.
##
utility_names.append('bsc_bdir_prune')
def bsc_bdir_prune(str, sep, match):
    t = clean_split(str, sep)
    if (env['DEFS']['BSC_VERSION'] >= 15480):
        try:
            while 1:
                i = t.index(match)
                del t[i]
        except ValueError:
            pass
    return string.join(t, sep)
    
##
## one_line_cmd --
##     Issue a shell command and return the first line of output
##
def one_line_cmd(cmd):
    p = os.popen(cmd)
    r = p.read().rstrip()
    p.close()
    return r


##
## awb_resolver --
##     Ask awb-resolver for some info.  Return the first line.
##
def awb_resolver(arg):
    return one_line_cmd("awb-resolver " + arg)


############################################################################
############################################################################
##
## SCons configuration.
##
############################################################################
############################################################################

##
## env.Clone() is new as of 0.97.  It used to be called Copy().
##
import SCons.Environment
try:
    SCons.Environment.Environment.Clone
except AttributeError:
    SCons.Environment.Environment.Clone = SCons.Environment.Environment.Copy


############################################################################
############################################################################
##
## Build rules
##
############################################################################
############################################################################

# Bluespec compains about signature mismatches if we use this to avoid
# recompiling across synthesis boundaries.
#TargetSignatures('content')

APM_NAME = env['DEFS']['APM_NAME']
BSC = env['DEFS']['BSC']
BSC_FLAGS_SIM = env['DEFS']['BSC_FLAGS_SIM']
BSC_FLAGS_VERILOG = env['DEFS']['BSC_FLAGS_VERILOG']
LDFLAGS = env['DEFS']['LDFLAGS']
TMP_BSC_DIR = env['DEFS']['TMP_BSC_DIR']
WORKSPACE_ROOT = env['DEFS']['WORKSPACE_ROOT']

##
## DEBUG or OPT build?  User can override the workspace default rule by
## specifying either OPT=1 or DEBUG=1 on the scons command line.
##
if (int(ARGUMENTS.get('OPT', 0))):
    DEBUG = 0
elif (int(ARGUMENTS.get('DEBUG', 0))):
    DEBUG = 1
else:
    DEBUG = int(awb_resolver('-config=debug'))

##
## Enable tracing (software side debugging)?  Always enabled in debug mode.
##
TRACE = int(ARGUMENTS.get('TRACE', 0))
if (DEBUG):
    TRACE = 1

##
## Override Xilinx COST_TABLE with command line
##
env['DEFS']['COST_TABLE'] = ARGUMENTS.get('COST_TABLE', env['DEFS']['COST_TABLE'])

##
## Build events into model?
##
enable_events = int(ARGUMENTS.get('EVENTS', -1))
if (enable_events == -1):
    enable_events = int(awb_resolver('-config=events'))

if (enable_events == 0):
    bsc_events_flag = '-D HASIM_EVENTS_ENABLED=False'
    cpp_events_flag = ''
else:
    bsc_events_flag = '-D HASIM_EVENTS_ENABLED=True'
    cpp_events_flag = '-DHASIM_EVENTS_ENABLED'

BSC_FLAGS_VERILOG += ' ' + bsc_events_flag
env['DEFS']['BSC_FLAGS_VERILOG'] = BSC_FLAGS_VERILOG

BSC_FLAGS_SIM += ' ' + bsc_events_flag
env['DEFS']['BSC_FLAGS_SIM'] = BSC_FLAGS_SIM


ROOT_WRAPPER_SYNTH_ID = 'mk_' + env['DEFS']['ROOT_DIR_MODEL'] + '_Wrapper'

if env['DEFS']['GIVEN_CS'] != '':
    SW_EXE_OR_TARGET = env['DEFS']['ROOT_DIR_SW'] + '/obj/' + APM_NAME + '_sw.exe'
    SW_EXE = [SW_EXE_OR_TARGET]
else:
    SW_EXE_OR_TARGET = '$TARGET'
    SW_EXE = []


# What is the Bluespec compiler version?
bsc_version = 0

bsc_ostream = os.popen('bsc -verbose')
ver_regexp = re.compile('^Bluespec Compiler, version.*\(build ([0-9]+),')
for ln in bsc_ostream.readlines():
    m = ver_regexp.match(ln)
    if (m):
        bsc_version = int(m.group(1))
bsc_ostream.close()

if bsc_version == 0:
    print "Failed to get Bluespec compiler version"
    sys.exit(1)

env['DEFS']['BSC_VERSION'] = bsc_version


############################################################################
##
## Rules for HW subdirectory.  These are shared by all targets.
##
############################################################################
env['DEFS']['CWD_REL'] = env['DEFS']['ROOT_DIR_HW_MODEL']
env['DEFS']['BSC_FLAGS'] = env['DEFS']['BSC_FLAGS_VERILOG']
Export('env ' + " ".join(utility_names))
wrapper_v = SConscript([env['DEFS']['ROOT_DIR_HW_MODEL'] + '/SConscript'])

BuildDir(TMP_BSC_DIR, '.', duplicate=0)
env['ENV']['BUILD_DIR'] = env['DEFS']['BUILD_DIR']  # need to set the builddir for synplify


############################################################################
##
## Rules for building a Bluesim EXE.
##
############################################################################

bsc_sim_command = BSC + ' ' + BSC_FLAGS_SIM + ' ' + LDFLAGS + ' -o $TARGET'

if (env['DEFS']['BSC_VERSION'] >= 13013):
    # 2008.01.A compiler allows us to pass C++ arguments.
    if (DEBUG):
        bsc_sim_command += ' -Xc++ -O0'
    else:
        bsc_sim_command += ' -Xc++ -O1'

bsc_sim_command += \
    ' -sim -e ' + ROOT_WRAPPER_SYNTH_ID + ' -simdir ' + \
    TMP_BSC_DIR + ' ' + env['DEFS']['GEN_BAS'] + ' ' + env['DEFS']['GIVEN_BAS'] + \
    ' ' + env['DEFS']['BDPI_CS']

sbin = env.Command(
    TMP_BSC_DIR + '/' + APM_NAME + '_hw.exe',
    wrapper_v + clean_split(env['DEFS']['GIVEN_VERILOGS'], sep = ' ') + clean_split(env['DEFS']['BDPI_CS'], sep=' '),
    bsc_sim_command)

if env.GetOption('clean'):
    os.system('rm -rf .bsc')

#
# The final step must leave a few well known names:
#   APM_NAME must be the software side, if there is one.  If there isn't, then
#   it must be the Bluesim image.
#
exe = env.Command(
    APM_NAME + '_hw.exe',
    sbin + SW_EXE,
    [ '@ln -fs ${SOURCE} ${TARGET}',
      '@ln -fs ${SOURCE}.so ${TARGET}.so',
      '@ln -fs ' + SW_EXE_OR_TARGET + ' ' + APM_NAME,
      Delete(APM_NAME + '_hw.vexe'),
      Delete(APM_NAME + '_hw.errinfo') ])

env.Alias('exe', exe)



############################################################################
##
## Rules for building a Verilog simulation vexe
##
############################################################################

vexe_gen_command = \
    BSC + ' ' + BSC_FLAGS_VERILOG + ' -vdir ' + env['DEFS']['ROOT_DIR_HW'] + '/' + env['DEFS']['ROOT_DIR_MODEL'] + '/' + env['DEFS']['TMP_BSC_DIR'] + \
    ' -o $TARGET -verilog -e ' + ROOT_WRAPPER_SYNTH_ID + \
    ' $SOURCES ' + env['DEFS']['GIVEN_BAS']

vbin = env.Command(
    TMP_BSC_DIR + '/' + APM_NAME + '_hw.vexe',
    clean_split(env['DEFS']['GEN_VS'], sep = ' ') + clean_split(env['DEFS']['GIVEN_VERILOGS'], sep = ' ') + clean_split(env['DEFS']['GIVEN_VHDS'], sep = ' ') + clean_split(env['DEFS']['BDPI_CS'], sep=' '),
    [ vexe_gen_command,
      Delete('directc.sft') ])


vexe = env.Command(
    APM_NAME + '_hw.vexe',
    vbin + SW_EXE,
    [ '@echo "#!/bin/sh" > $TARGET',
      '@echo "./$SOURCE +bscvcd \$*" >> $TARGET',
      '@chmod a+x $TARGET',
      '@ln -fs ' + SW_EXE_OR_TARGET + ' ' + APM_NAME,
      Delete(APM_NAME + '_hw.exe'),
      Delete(APM_NAME + '_hw.exe.so'),
      Delete(APM_NAME + '_hw.errinfo') ])

env.Alias('vexe', vexe)



############################################################################
##
## Rules for building a Xilinx bit image
##
############################################################################

TMP_XILINX_DIR = env['DEFS']['TMP_XILINX_DIR']
XILINX_APM_NAME = TMP_XILINX_DIR + '/' + APM_NAME

SYNTH_TOP = env['DEFS']['SYNTH_TOP']
XILINX_SYNTH_TOP = TMP_XILINX_DIR + '/' + SYNTH_TOP

FPGA_PART_XILINX = env['DEFS']['FPGA_PART_XILINX']

wrapper_builds = []

# Concatenate SDC files
if len(env['DEFS']['GIVEN_SDCS']) != 0:
    synplify_sdc = env.Command(
    XILINX_APM_NAME + '.sdc',
    clean_split(env['DEFS']['GIVEN_SDCS'], sep = ' '),
    'cat $SOURCES > $TARGET')
else:
    synplify_sdc = env.Command(
    XILINX_APM_NAME + '.sdc',
    clean_split(env['DEFS']['GIVEN_SDCS'], sep = ' '),
    'touch $TARGET') 

if(env['DEFS']['SYNTHESIS_TOOL'] == "synplify_pro"):
    top_netlist = env.Command(
        XILINX_APM_NAME + '.edf',
        wrapper_v + clean_split(env['DEFS']['GIVEN_VERILOGS'], sep = ' ') + ['config/' + APM_NAME + '.synplify.prj'] + synplify_sdc,
        [ Delete(XILINX_APM_NAME + '.srr'),
          Delete(XILINX_APM_NAME + '_xst.xrpt'),
          'synplify_pro -batch config/' + APM_NAME + '.synplify.prj' ])

    Clean(top_netlist,  XILINX_APM_NAME + '.srp')
else:
    #
    # Parallel Xst build.  Each synthesis boundary is independent.
    #
    for wrapper in env['DEFS']['SYNTH_WRAPPERS'].split():
        # we must tweak the xst files of the internal module list
        # to prevent the insertion of iobuffers
        newXSTFile = open('config/' + wrapper + '.modified.xst','w')
        oldXSTFile = open('config/' + wrapper + '.xst','r')
        newXSTFile.write(oldXSTFile.read());
        newXSTFile.write('-iobuf no\n');
        newXSTFile.close();
        oldXSTFile.close();

        w = env.Command(
            TMP_XILINX_DIR + '/' + wrapper + '.ngc',
            wrapper_v + clean_split(env['DEFS']['GIVEN_VHDS'], sep = ' ') + clean_split(env['DEFS']['GIVEN_VERILOGS'], sep = ' ') + clean_split(env['DEFS']['GIVEN_NGCS'], sep = ' ') + ['config/' + wrapper + '.xst'],
            [ Delete(TMP_XILINX_DIR + '/' + wrapper + '.srp'),
              Delete(TMP_XILINX_DIR + '/' + wrapper + '_xst.xrpt'),
              'xst -intstyle silent -ifn config/' + wrapper + '.modified.xst -ofn ' + TMP_XILINX_DIR + '/' + wrapper + '.srp',
              '@echo xst ' + wrapper + ' build complete.' ])

        wrapper_builds += w
        Clean(w,  TMP_XILINX_DIR + '/' + wrapper + '.srp')

    top_netlist = env.Command(
        XILINX_SYNTH_TOP + '.ngc',
        wrapper_v + clean_split(env['DEFS']['GIVEN_VHDS'], sep = ' ') + clean_split(env['DEFS']['GIVEN_VERILOGS'], sep = ' ') + clean_split(env['DEFS']['GIVEN_NGCS'], sep = ' ') + ['config/' + SYNTH_TOP + '.xst'],
        [ Delete(XILINX_SYNTH_TOP + '.srp'),
          Delete(XILINX_SYNTH_TOP + '_xst.xrpt'),
          'xst -intstyle silent -ifn config/' + SYNTH_TOP + '.xst -ofn ' + XILINX_SYNTH_TOP + '.srp',
          '@echo xst ' + SYNTH_TOP + ' build complete.' ])

    Clean(top_netlist,  XILINX_SYNTH_TOP + '.srp')


# Concatenate UCF files
xilinx_ucf = env.Command(
    XILINX_APM_NAME + '.ucf',
    clean_split(env['DEFS']['GIVEN_UCFS'], sep = ' '),
    'cat $SOURCES > $TARGET')


if len(env['DEFS']['GIVEN_BMMS']) != 0:
    xilinx_bmm = env.Command(
    XILINX_APM_NAME + '.bmm',
    clean_split(env['DEFS']['GIVEN_BMMS'], sep = ' '),
    'cat $SOURCES > $TARGET')
    #./ works around crappy xilinx parser
    bmm = ' -bm ./' + XILINX_APM_NAME + '.bmm' 
else:
    xilinx_bmm = ''
    bmm = ''

xilinx_ngd = env.Command(
    XILINX_APM_NAME + '.ngd',
    top_netlist + xilinx_ucf + xilinx_bmm,
    [ Delete(XILINX_APM_NAME + '.bld'),
      Delete(XILINX_APM_NAME + '_ngdbuild.xrpt'),
      # Xilinx project files are created automatically by Xilinx tools, but not
      # needed for command line tools.  The project files may be corrupt due
      # to parallel invocation of xst.  Until we figure out how to move them
      # or guarantee their safety, just delete them.
      Delete('xlnx_auto_0.ise'),
      Delete('xlnx_auto_0_xdb'),
      'ngdbuild -p ' + FPGA_PART_XILINX + ' -sd ' + env['DEFS']['ROOT_DIR_HW_MODEL'] + ' -uc ' + XILINX_APM_NAME + '.ucf ' + bmm + ' $SOURCE $TARGET',
      Move(TMP_XILINX_DIR + '/netlist.lst', 'netlist.lst') ])


Depends(xilinx_ngd, wrapper_builds)

Clean(xilinx_ngd, TMP_XILINX_DIR + '/netlist.lst')

# Alias for everything up to map...
env.Alias('xst', xilinx_ngd + SW_EXE)


#
# Use a cached post par ncd to guide map and par?  This is off by default since
# the smart guide option can make place & route fail when it otherwise would have
# worked.  It doesn't always improve run time, either.  To turn on smart guide
# either define the environment variable USE_SMARTGUIDE or set
# USE_SMARTGUIDE on the scons command line to a non-zero value.
#
smartguide_cache_dir = env['DEFS']['WORKSPACE_ROOT'] + '/var/xilinx_ncd'
smartguide_cache_file = APM_NAME + '_par.ncd'
if not os.path.isdir(smartguide_cache_dir):
    os.mkdir(smartguide_cache_dir)

if ((int(ARGUMENTS.get('USE_SMARTGUIDE', 0)) or env['ENV'].has_key('USE_SMARTGUIDE')) and
    (FindFile(APM_NAME + '_par.ncd', [smartguide_cache_dir]) != None)):
    smartguide = ' -smartguide ' +  smartguide_cache_dir + '/' + smartguide_cache_file
else:
    smartguide = ''


# Map
xilinx_map = env.Command(
    [ XILINX_APM_NAME + '_map.ncd', XILINX_APM_NAME + '.pcf' ],
    xilinx_ngd,
    [ Delete(XILINX_APM_NAME + '_map.map'),
      Delete(XILINX_APM_NAME + '_map.mrp'),
      Delete(XILINX_APM_NAME + '_map.ncd'),
      Delete(XILINX_APM_NAME + '_map.ngm'),
      Delete(XILINX_APM_NAME + '_map.psr'),
      'map -cm balanced -timing ' + smartguide + ' -t ' + env['DEFS']['COST_TABLE'] + ' ' +  env['DEFS']['MAP_OPTIONS'] + ' -logic_opt on -ol high -register_duplication -retiming on -pr b -c 100 -p ' + FPGA_PART_XILINX + ' -o $TARGET $SOURCE ' + XILINX_APM_NAME + '.pcf' ])

Clean(xilinx_map, TMP_XILINX_DIR + '/xilinx_device_details.xml')




# Place and route
xilinx_par = env.Command(
    XILINX_APM_NAME + '_par.ncd',
    xilinx_map,
    [ Delete(XILINX_APM_NAME + '_par.pad'),
      Delete(XILINX_APM_NAME + '_par.par'),
      Delete(XILINX_APM_NAME + '_par.ptwx'),
      Delete(XILINX_APM_NAME + '_par.unroutes'),
      Delete(XILINX_APM_NAME + '_par.xpi'),
      Delete(XILINX_APM_NAME + '_par_pad.csv'),
      Delete(XILINX_APM_NAME + '_par_pad.txt'),
      'par -w -ol high ' + smartguide + ' -t ' + env['DEFS']['COST_TABLE'] + ' ' + XILINX_APM_NAME + '_map.ncd $TARGET ' + XILINX_APM_NAME + '.pcf',
      Copy(smartguide_cache_dir + '/' + smartguide_cache_file, '$TARGET') ])


# Generate the FPGA timing report -- this report isn't built by default.  Use
# the "timing" target to generate it
xilinx_trce = env.Command(
    XILINX_APM_NAME + '_par.twr',
    [ xilinx_par, XILINX_APM_NAME + '.pcf' ],
    'trce -e 100 $SOURCES -o $TARGET')



if len(env['DEFS']['GIVEN_ELFS']) != 0:
    elf = ' -bd ' + str.join(' -bd ',clean_split(env['DEFS']['GIVEN_ELFS'], sep = ' '))
else:
    elf = ''




# Generate the FPGA image
xilinx_bit = env.Command(
    XILINX_APM_NAME + '_par.bit',
    [ 'config/' + APM_NAME + '.ut', xilinx_par],
    [ Delete('config/signature.sh'),
      'bitgen ' + elf + ' -f $SOURCES $TARGET ' + XILINX_APM_NAME + '.pcf' ])

Depends(xilinx_bit, clean_split(env['DEFS']['GIVEN_ELFS'], sep = ' '));

# Generate the signature for the FPGA image
signature = env.Command(
    'config/signature.sh',
    xilinx_bit,
    [ '@echo \'#!/bin/sh\' > $TARGET',
      '@echo signature=\\"' + APM_NAME + '-`md5sum $SOURCE | sed \'s/ .*//\'`\\" >> $TARGET' ])

#
# The final step must leave a few files in well-known locations since they are
# used by the run scripts.  APM_NAME is the software side, if there is one.
#
loader = env.Command(
    APM_NAME + '_hw.errinfo',
    signature + SW_EXE + xilinx_trce,
    [ '@ln -fs ' + SW_EXE_OR_TARGET + ' ' + APM_NAME,
      Delete(APM_NAME + '_hw.exe'),
      Delete(APM_NAME + '_hw.exe.so'),
      Delete(APM_NAME + '_hw.vexe'),
      '@echo "++++++++++++ Post-Place & Route ++++++++"',
      '@' + awb_resolver('tools/scripts/hasim-xilinx-summary') + ' ' +
          XILINX_APM_NAME + '_map.map ' +
          XILINX_APM_NAME + '_par.par ' +
          APM_NAME + '_hw.errinfo' ])
      
env.Alias('bit', loader)


##
## Clean up a few extra files not described in the build rules
##
if env.GetOption('clean'):
    os.system('cd ' + TMP_XILINX_DIR + '; rm -f ' + APM_NAME + '*')
    os.system('rm -f APM_NAME')


############################################################################
##
## Rules for building the software side.  Invoke scripts in subdirectories
## to define the objects needing to be built.  The final link is defined
## here.
##
############################################################################

def host_defs():
    hostos = one_line_cmd('uname -s')
    hostmachine = one_line_cmd('uname -m')

    if (hostos == 'FreeBSD'):
        hflags = '-DHOST_FREEBSD'
    else:
        hflags = '-DHOST_LINUX'
        if (hostmachine == 'ia64'):
            hflags += ' -DHOST_LINUX_IA64'
        else:
            hflags += ' -DHOST_LINUX_X86'

    return hflags


if SW_EXE != []:
    inc_paths = clean_split(env['DEFS']['SW_INC_DIRS'], sep = ' ')
    libs = clean_split(env['DEFS']['SW_LIBS'], sep = ' ')
    cc_flags = host_defs()
    cc_flags += ' ' + cpp_events_flag
    if (DEBUG):
        cc_flags += ' -DASIM_ENABLE_ASSERTIONS'
    if (TRACE):
        cc_flags += ' -DASIM_ENABLE_TRACE'
    cc_flags += ' -DAPM_NAME=\\"' + APM_NAME + '\\"'

    ##
    ## These will be defined if the m5 simulator is part of the model
    ##
    M5_BUILD_DIR = env['DEFS']['M5_BUILD_DIR'] 
    if (M5_BUILD_DIR != ''):
        # m5 needs Python library
        inc_paths += [ os.path.join(sys.exec_prefix, 'include', 'python' + sys.version[:3]) ]
        python_zip = os.path.join(awb_resolver(M5_BUILD_DIR), 'm5py.zip')

        cc_flags += ' -DTRACING_ON=1'
        if (env['DEFS']['SIMULATED_ISA'] != ''):
            cc_flags += ' -DTHE_ISA=' + env['DEFS']['SIMULATED_ISA'] + '_ISA'

        if (DEBUG):
            cc_flags += ' -DDEBUG'
            # Swap the optimized m5 library for a debugging one
            tmp_libs = []
            for lib in libs:
                if (os.path.basename(lib) == 'libm5_opt.a'):
                    tmp_libs += [ os.path.join(os.path.dirname(lib), 'libm5_debug.a') ]
                else:
                    tmp_libs += [ lib ]
            libs = tmp_libs

    if (DEBUG):
        copt_flags = '-ggdb3 '
    else:
        copt_flags = '-g -O2 '

    # CPPPATH defines both gcc include path and dependence path for
    # SCons.  The '#' forces paths to be relative to the root of the build.
    sw_env = env.Clone(CCFLAGS = copt_flags + cc_flags,
                       LINKFLAGS = copt_flags,
                       CPPPATH = [ '#/' + env['DEFS']['ROOT_DIR_SW_INC'],
                                   '#/' + env['DEFS']['ROOT_DIR_HW_MODEL'],
                                   '#/iface/build/include',
                                   '.' ] + inc_paths)

    sw_env['DEFS']['CWD_REL'] = sw_env['DEFS']['ROOT_DIR_SW_MODEL']

    Export('sw_env ' + " ".join(utility_names))
    sw_build_dir = sw_env['DEFS']['ROOT_DIR_SW'] + '/obj'
    sw_objects = SConscript([env['DEFS']['ROOT_DIR_SW_MODEL'] + '/SConscript'],
                            build_dir = sw_build_dir,
                            duplicate = 0)

    sw_libpath = [ '.' ]
    sw_link_libs = [ 'pthread' ]

    sw_link_tgt = SW_EXE


    ##
    ## m5 needs libz, libmysqlclient and Python library
    ##
    if (M5_BUILD_DIR != ''):
        sw_link_libs += [ 'z' ]

        if (os.path.exists(os.path.join(sys.exec_prefix, 'lib' , 'libmysqlclient.a'))):
            sw_link_libs += [ 'mysqlclient' ]
        elif (os.path.exists(os.path.join(sys.exec_prefix, 'lib', 'mysql' , 'libmysqlclient.a'))):
            sw_link_libs += [ 'mysqlclient' ]

        # m5 needs python
        sw_libpath += [ os.path.join(sys.exec_prefix, 'lib') ]
        sw_link_libs += [ 'python' + sys.version[:3] ]

        # m5 links a temporary file then adds Python code
        sw_link_tgt = [ SW_EXE[0] + '.no_python' ]


    ##
    ## Put libs on the list of objects twice as a hack to work around the
    ## inability to specify the order of %library declarations across separate
    ## awb files.  Unix ld only searches libraries in command line order.
    ##
    sw_exe = sw_env.Program(sw_link_tgt, sw_objects + libs + libs, LIBPATH=sw_libpath, LIBS=sw_link_libs)

    if (M5_BUILD_DIR != ''):
        ##
        ## Define a simple SCons builder to concatenate files.  Used to append the
        ## Python zip archive to the executable.
        ##
        concat_builder = Builder(action = Action(['cat $SOURCES > $TARGET',
                                                  'chmod +x $TARGET']))
        sw_env.Append(BUILDERS = { 'Concat' : concat_builder })

        # Append Python code to the binary
        sw_exe = sw_env.Concat(SW_EXE, [ sw_exe, python_zip ])

############################################################################
############################################################################

##
## Set a default target
##
if (env['DEFS']['MAKE_ALL_TARGET'] != ''):
    Default(env['DEFS']['MAKE_ALL_TARGET'])
else:
    Default(exe)
